---
title: "data_wrangle_trawl"
author: "Tim van der Stap & Julian Gan"
date: "5/12/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
library(tidyverse)
library(lubridate)
library(readxl)
library(here)
library(worrms)
library(obistools)
library(parsedate)
library(googledrive)
library(uuid)
```

The first step is to download the files from GoogleDrive and save it in a local folder. One file contains the bridgelog data and aggregated data, whereas the other contains specimen-specific catch measurements. 

``` {r file_download}
drive_download(file = "https://docs.google.com/spreadsheets/d/1xm_MIx_y8nsvA8I-7G33RcQ_j7w-Qmm-/edit#gid=168338968", 
               path = here::here("Trawl", "raw_data", 
                                 "2020_GoA_Fish_Trawl_data.xlsx"),
               overwrite = TRUE)

drive_download(file = "https://docs.google.com/spreadsheets/d/1m_o8Ux3s-0CS4rE3CP7cT3kFOY4-e97B/edit#gid=1644980763",
               path = here::here("Trawl", "raw_data", 
                                 "2020_GoA_Fish_Specimen_data.xlsx"),
               overwrite = TRUE)
```

The trawl data is read from the local folder, and the date/time is formatted to the iso 8601 standards. Additionally, four extra columns are created for each `eventID`: "project", "cruise", "station" and "trawl". The fish trawl abundance data file also includes the bridgelog file sheet, where metadata is recorded. When reading the data in from the local folder make sure that a clear distinction is made between the bridgelog (metadata) and the catch data. 

``` {r trawl_data_prep}
trawl2020 <- read_excel(here("Trawl", "raw_data", "2020_GoA_Fish_Trawl_data.xlsx"), sheet = "BRIDGE_LOG_FINAL") %>%
  mutate(Time = format(TIME_FISHING_START, "%H:%M:%S"),
         eventDate = format_iso_8601(as.POSIXct(paste(EVENT_DATE, Time),
                                                format = "%Y-%m-%d %H:%M:%S",
                                                tz = "Asia/Kamchatka")), # Confirm this timezone. 
         eventDate = str_replace(eventDate, "\\+00:00", "Z"),
         project = "IYS",
         cruise = paste(project, "GoA2020", sep = ":"), 
         station = paste(cruise, SET_NUMBER, sep="_Stn"),
         trawl = paste(station, "trawl", sep=":"))

trawl2020_specimen <- read_excel(here("Trawl", "raw_data", "2020_GoA_Fish_Specimen_data.xlsx"), 
                                 sheet = "SPECIMEN_FINAL") %>%
  mutate(project = "IYS",
         cruise = paste(project, "GoA2020", sep = ":"),
         station = paste(cruise, SET_NUMBER, sep = "_Stn"),
         trawl = paste(station, "trawl", sep = ":"))
```

## Event Core 

Next, dataframes are created for each unique `eventID` layer, with unique associated columns. Eventually, the data frames get joined, and the event table gets saved locally and in Google Drive. The column `eventRemarks` is not a required column, but includes descriptive information pertaining to any issues that arose during the setting of the trawl net. 

``` {r trawl_event, eval = FALSE}
trawl2020_project <- trawl2020 %>%
  select(eventID = project) %>%
  distinct(eventID)

trawl2020_cruise <- trawl2020 %>% 
  select(eventID = cruise,
         parentEventID = project) %>% 
  distinct(eventID, .keep_all = TRUE) 

trawl2020_station <- trawl2020 %>% 
  select(eventID = station,
         parentEventID = cruise) %>% 
  distinct(eventID, .keep_all = TRUE) 

# The coordinates associated to the trawl need to be presented in a LINESTRING:
trawl2020_coordinates <- trawl2020 %>%
  select(eventID = trawl,
         START_LAT_DECDEGREE,
         START_LONG_DECDEGREE,
         END_LAT_DECDEGREE,
         END_LONG_DECDEGREE) %>%
  mutate(footprintWKT = paste("LINESTRING (", START_LONG_DECDEGREE, START_LAT_DECDEGREE, ",", 
                              END_LONG_DECDEGREE, END_LAT_DECDEGREE, ")")) %>%
  filter(!is.na(END_LAT_DECDEGREE)) # Station 20 needs end lat and long included - this issue needs to be resolved. 

trawl2020_linestring <- obistools::calculate_centroid(trawl2020_coordinates$footprintWKT)
trawl2020_linestring <- cbind(trawl2020_coordinates, trawl2020_linestring) %>%
  select(eventID, footprintWKT, decimalLatitude, decimalLongitude, coordinateUncertaintyInMeters)

trawl2020_trawl <- trawl2020 %>% 
  select(eventID = trawl,
         parentEventID = station,
         eventDate,
         fieldNotes = PROBLEM_DESCRIPTION
         ) %>%
  mutate(minimumDepthInMeters = 0, # trawl was at the surface
         maximumDepthInMeters = pmax(trawl2020$`NET OPENING DEPTH (metres) - 15 min`,
                                     trawl2020$`NET OPENING DEPTH (metres) - 30 min`,
                                     trawl2020$`NET OPENING DEPTH (metres) - 45 min`,
                                     trawl2020$`NET OPENING DEPTH (metres) - END`, na.rm = TRUE),
         samplingProtocol = "surface trawl", # if possible add DOI to paper here
         sampleSizeValue = trawl2020$`DURATION OF TOW (min)`,
         sampleSizeUnit = "min",
         waterBody = case_when(
           trawl2020$LOCATION == "GoA" ~ "Gulf of Alaska"),
         locationRemarks = case_when(
           trawl2020$LOCATION == "Canadian EEZ" ~ "Canadian EEZ")
         ) %>%
  left_join(trawl2020_linestring, by = "eventID") %>% 
  distinct(eventID, .keep_all = TRUE)

trawl2020_event <- bind_rows(trawl2020_project, trawl2020_cruise, trawl2020_station, trawl2020_trawl) %>% 
  mutate(type = "Event")

col_order <- c("eventID", "parentEventID", "eventDate", "decimalLatitude", "decimalLongitude", "footprintWKT", "coordinateUncertaintyInMeters", "minimumDepthInMeters", "maximumDepthInMeters", "samplingProtocol", "sampleSizeValue", "sampleSizeUnit", "waterBody", "locationRemarks", "type", "fieldNotes")
trawl2020_event <- trawl2020_event[, col_order]

write_csv(trawl2020_event, here("Trawl", "tidy_data", "trawl2020_event.csv"))
drive_upload(here("Trawl", "tidy_data", "trawl_event.csv"),
             path = "",
             name = "trawl_event.csv",
             overwrite = TRUE)
```

## Occurrence

As the trawl data consists of biotic data, an occurrence table has to be created as well, whereby unique individual `occurrenceIDs` get linked to the `eventID`. The `occurrenceID` is created from the `eventID`, and any measurements pertaining to the specific individual will be associated to that `occurrenceID` in the extended MeasurementOrFact Core.

The Occurrence Core will consist of two tables merged, one from the aggregated (summary) catch data (`catch_final`). In this dataframe is also listed how many species-specific individuals within each trawl were used to measure individual lenghts and weights. The occurrenceID for the aggregated catch data will have the format `IYS:GoA2020_Stn1:trawl:occ-1`, whereas those individual measurements that fall under this occurrence will have the format `IYS:GoA2020_Stn1:trawl:occ-1-001` etc. Additionally, a column `occurrenceRemarks` will be included to indicate that that specific `occurrenceID` is a subset of the aggregated catch data. 

A required column for the Occurrence table is the term, `occurrenceStatus`, which is used for presence/absence data. The package `worrms` is used to generate hierarchial taxonomic information on the species observed. For the `scientificNameID`, we look up the species on the WoRMS website (http://www.marinespecies.org/). 

Finally, we can do a quick check to make sure that all the unique species are included in the trawl_occ dataframe. We need to make sure that the output is TRUE. If confirmed, the Occurrence table can be saved locally and in the correct Google Drive folder. We also need to make sure that if columns 'SPECIES' or 'SPECIES (Description if needed)' make mention of a lifestage, we need to include this in the occurrence Core. 

``` {r trawl2020_occ, eval = FALSE}
# First, let's create an occurrence table from the overall catch data
trawl2020_allCatch <- read_excel(here("Trawl", "raw_data", "2020_GoA_Fish_Trawl_data.xlsx"), 
                                 sheet = "CATCH_FINAL") %>%
  mutate(project = "IYS",
         cruise = paste(project, "GoA2020", sep = ":"),
         station = paste(cruise, SET_NUMBER, sep = "_Stn"),
         trawl = paste(station, "trawl", sep = ":")) %>%
  rename(scientificname = SPECIES) %>% 
  mutate(lifeStage = case_when(grepl("larvae", trawl2020_allCatch$scientificname) ~ "larvae",
                               grepl("larvae", trawl2020_allCatch$`SPECIES (Description if needed)`) ~ "larvae",
                               grepl("eggs", trawl2020_allCatch$scientificname) ~ "eggs",
                               grepl("eggs", trawl2020_allCatch$`SPECIES (Description if needed)`) ~ "eggs",
                               grepl("juv", trawl2020_allCatch$scientificname) ~ "juvenile",
                               grepl("juv", trawl2020_allCatch$`SPECIES (Description if needed)`) ~ "juvenile",
                               grepl("egg", trawl2020_allCatch$scientificname) ~ "egg",
                               grepl("egg", trawl2020_allCatch$`SPECIES (Description if needed)`) ~ "egg"))


trawl2020_allCatch_scientificnames <- worrms::wm_records_names(unique(trawl2020_allCatch$scientificname)) %>% bind_rows()
trawl2020_allCatch_taxa <- left_join(trawl2020_allCatch, trawl2020_allCatch_scientificnames, by = "scientificname")

# You'll notice that not all unique_taxa have associated taxonomic hierarchial information. Let's inspect these observations as they might be either misspelled, or a non-Latin name is provided. 
unidentified_species <- trawl2020_allCatch_taxa %>% filter(is.na(AphiaID)) %>% distinct(scientificname)

# A total of 23 species could not be matched to a record within the WoRMS database. Most often this is due to spelling errors, the inclusion of '.sp', or the lack of supplying a Latin name. I manually check these species in the WoRMS database and confirm with the data provider that the suggested species are the ones meant. These species will then be corrected in the trawl2020_allCatch_taxa data frame. 

# First step, remove any  mentions of 'sp.' or 'sp'. Some species also have 'sp' included in their Latin name so make sure you "anchor" the string you want replaced using \\b. 
trawl2020_allCatch$scientificname <- gsub("\\b sp.\\b|\\b sp\\b", "", trawl2020_allCatch$scientificname)

# For the remaining species, use gsub to replace them with appropriate record in WoRMS. Again, confirm this with the data provider. 
trawl2020_allCatch$scientificname <- mgsub::mgsub(trawl2020_allCatch$scientificname,
                         c("Paralichthydidae", "Paralepidadae", "Sergestes similus", "Salps", "Abraliopsis Felis",
                           "Euphausiid", "Gooseneck barnacle", "Chiroteuthis calix", "Glycptocephalus zacharius",
                           "squid", "Fish eggs", "jellyfish", "myctophiids", "goose neck barnacle", "gonatidae",
                           "Flatfish larvae", "Ptereotrachea"),
                         c("Paralichthyidae", "Paralepidapedon", "Sergestes similis", "Salpa", "Abraliopsis felis",
                           "Euphausiidae", "Pollicipes pollicipes", "Chiroteuthis calyx", "Glyptocephalus zachirus",
                           "Teuthida", "Pisces", "Cnidaria", "Myctophidae", "Pollicipes pollicipes", "Gonatidae",
                           "Pleuronectiformes", "Pterotrachea"))

# So now we can run worrms::wm_records_names again, and there should be no NA in the AphiaID column.
trawl2020_allCatch_worms <- worrms::wm_records_names(unique(trawl2020_allCatch$scientificname)) %>% bind_rows()
trawl2020_occ <- left_join(trawl2020_allCatch, trawl2020_allCatch_worms, by = "scientificname") %>%
  rename(eventID = trawl,
         scientificNameAuthorship = authority,
         taxonomicStatus = status,
         taxonRank = rank,
         scientificName = scientificname,
         scientificNameID = lsid,
         organismQuantity = CATCH_NUMBER) %>%
  mutate(occurrenceID = paste(eventID, "occ", row_number(), sep = ":"),
         occurrenceStatus = "present") %>%
  select(eventID, occurrenceID, occurrenceStatus, organismQuantity,scientificName, scientificNameID,
         scientificNameAuthorship, taxonomicStatus, taxonRank, parentNameUsageID, kingdom, phylum, 
         class, order, family, genus, lifeStage)

# Save the file locally
write_csv(trawl2020_occ, here("Trawl", "tidy_data", "trawl2020_occ.csv"))
```

So now we have created the first Occurrence table, which includes the overall catch data. In the trawl2020_allCatch dataframe, column `Length (N)` indicates how many individuals at each trawl were measured for their lengths. In the next section, we create a second occurrence table, with `occurrenceID`s created for each unique individual whose length has been measured. Where the `occurrenceID` in the previous chunk of code has the format of `IYS:GoA2020_Stn1:trawl:occ:1`, the `occurrenceID`s in the next section will have the format `IYS:GoA2020_Stn1:trawl:occ:1-001`. A column will have to be added to indicate that the individual measurements are a subset of the overall catch at that station. 

``` {r occ_species, eval = FALSE}
# Add occurrenceID to fish specimen data file:
trawl2020_specimen <- trawl2020_specimen %>%
  select(eventID = trawl,
         scientificname = SPECIES,
         SPECIES_DESCRIPTION) %>%
  mutate(occurrenceStatus = "present",
         occurrenceID = paste(eventID, "fish_occ", row_number(), sep = ":"))

unique_trawl2020_species <- unique(trawl2020_specimen$scientificname) 

trawl2020_scientificnames <- worrms::wm_records_names(unique_trawl2020_species)
trawl2020_scientificnames <- dplyr::bind_rows(trawl2020_scientificnames)

trawl2020_taxa <- left_join(trawl2020_specimen, trawl2020_scientificnames, by = "scientificname")

# To see which species have not been matched with a record in the WoRMS registry, filter for AphiaID = NA. 
unidentified_species <- trawl2020_taxa %>% filter(is.na(AphiaID)) %>% distinct(scientificname)

# There are 12 unique species that have been recorded for which the worrms package cannot find a match in the WoRMS database. A manual check confirms that these species have not been matched because of minor spelling mistakes etc. In the trawl2020_specimen these species are replaced using gsub(), and worrms is re-run to get the taxonomic information. For those species whose names have been changed, we need to confirm this is done correctly with the data provider!

trawl2020_specimen$scientificname <- mgsub::mgsub(trawl2020_specimen$scientificname,
                                           c("Abraliopsis Felis", "Oncorhynchus gorbusha", "Pterotrachea sp.", 
                                             "Aurelia sp.", "Phacellophoroa camtschatica", "Aequorea sp.", 
                                             "Chiroteuthis calix", "Dosidicus gigas?", "Glycptocephalus zacharius",
                                             "Unknown jelly", "Sebastes sp.", "Flatfish larvae"),
                                           c("Abraliopsis felis", "Oncorhynchus gorbuscha", "Pterotrachea",
                                             "Aurelia", "Phacellophora camtschatica", "Aequorea",
                                             "Chiroteuthis calyx", "Dosidicus gigas", "Glyptocephalus zachirus",
                                             "Cnidaria", "Sebastes", "Pleuronectiformes"))
unique_trawl_species <- unique(trawl2020_specimen$scientificname)

trawl2020_scientificnames_fnl <- worrms::wm_records_names(unique_trawl_species)
trawl2020_scientificnames_fnl <- dplyr::bind_rows(trawl2020_scientificnames_fnl)
trawl2020_occ <- left_join(trawl2020_specimen, trawl2020_scientificnames_fnl, by = "scientificname") %>%
  rename(scientificName = scientificname,
         scientificNameID = lsid,
         scientificNameAuthorship = authority,
         taxonomicStatus = status,
         taxonRank = rank) %>%
  select(eventID, occurrenceID, occurrenceStatus, scientificName, scientificNameID, scientificNameAuthorship,
         taxonomicStatus, taxonRank, parentNameUsageID, kingdom, phylum, class, order, family, genus)
```

To quality control whether each species in the original specimen file has been accounted for in the final Occurrence Core, use the following chunk of code. We also have to check whether the unique species listed in the specimen file match the unique species listed in the overall catch file, where numbers have been aggregated. 

``` {r trawl2020_occ_check}
all(unique_trawl_species == unique(trawl2020_occ$scientificName)) # Answer should be TRUE
```

To save the Occurrence Core, follow:

``` {r save_data, eval = FALSE}
write_csv(trawl2020_occ, here("Trawl", "tidy_data", "trawl2020_occ.csv"))
drive_upload(here("Trawl", "tidy_data", "trawl2020_occ.csv"),
             path = " ",
             name = "trawl_occ.csv",
             overwrite = TRUE)
```


## Extended MeasurementOrFact Extension

Although there exist Darwin Core terms related to class _Occurrence_ such as individualCount, organismQuantity, lifeStage, etc., OBIS recommends adding all measurements to the eMoF extension (De Pooter et al. 2007). There are three benefits of storing measurements in the eMoF extension instead of in the Occurrence core:

1. Individual counts and derived quantifications (abundance or biomass) can be captured without needing to create duplicate occurrence records
2. The measurementTypeID field enables reference to external controlled vocabularies (e.g. NERC server), rather than maintaining a vocabulary within OBIS, and
3. Allows an unlimited number of measurement parameters to be stored without altering table structure

From the Occurrence table, we filter for occurrenceStatus == "present", as these have the unique occurrenceIDs that have measurements associated to them. Next, we have to merge it with the trawl df, as that's where the measurements are stored. To merge these dataframes, we rename a few columns in the trawl df so we can merge by specific columns.

```{r eMoF}
trawl_emof_wrangle <- trawl_sp_wrangle %>% 
  filter(occurrenceStatus == "present")
  # Rename trawl column in dataframe `trawl` to `eventID` and use merge()
  # measurements are found in the trawl dataframe, so we need to transform that
  # dataframe slightly and merge it with the newly created trawl_emof:
trawl <- trawl %>% mutate(Species = paste(FISH1, FISH2, sep = " ")) %>%
  dplyr::rename(scientificName = Species,
                eventID = trawl)
trawl_emof <- merge(trawl_emof_wrangle, trawl, by = c("eventID", "scientificName", "Group")) %>%
  # We have to merge by Group as well because otherwise similar occIDs will be created for different lifestages within a single trawl set (i.e., if both adult and juvenile Chinook salmon are caught these will be given the same occID if it's only done by scientificName).
  mutate(LMIN = format(LMIN, digits = 2),
         LMAX = format(LMAX, digits = 2),
         MASSCATCH = format(MASSCATCH, digits = 4)
         ) %>% mutate_all(as.character) %>%
  pivot_longer(cols = c("Group","LMIN","LMAX","PIECES","MASSCATCH"),
               names_to = "measurementType", values_to = "measurementValue") %>% 
  mutate(measurementType = recode(measurementType,
                                  "Group" = "age class",
                                  "LMIN" = "minimum length",
                                  "LMAX" = "maximum length",
                                  "PIECES" = "number of individuals",
                                  "MASSCATCH" = "catch biomass"
                                  ),
         measurementTypeID = case_when(
           measurementType == "minimum length" ~ "http://vocab.nerc.ac.uk/collection/P01/current/OBSMINLX/",
           measurementType == "maximum length" ~ "http://vocab.nerc.ac.uk/collection/P01/current/OBSMAXLX/",
           measurementType == "number of individuals" ~ "http://vocab.nerc.ac.uk/collection/S06/current/S0600008/",
           measurementType == "catch biomass" ~ "http://vocab.nerc.ac.uk/collection/S06/current/S0600088/"
           ),
         measurementValue = recode(measurementValue,
                                   "(juv.)" = "juvenile",
                                   "(immature)" = "immature",
                                   "(mature)" = "mature"
                                   ),
         measurementValueID = case_when(
           measurementValue == "juvenile" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1127/",
           measurementValue == "immature" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1171/",
           measurementValue == "mature" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1116/"
           ),
         measurementUnit = case_when(
           measurementType == "number of individuals" ~ "individuals",
           measurementType == "minimum length" ~ "cm",
           measurementType == "maximum length" ~ "cm",
           measurementType == "catch biomass" ~ "kg"
           ),
         measurementUnitID = case_when(
           measurementUnit == "individuals" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UUUU/",
           measurementUnit == "cm" ~ "http://vocab.nerc.ac.uk/collection/P06/current/ULCM/",
           measurementUnit == "kg" ~ "http://vocab.nerc.ac.uk/collection/P06/current/KGXX/"
         )
  ) %>% 
  select(eventID, 
         occurrenceID, 
         measurementType, 
         measurementTypeID, 
         measurementValue, 
         measurementValueID,
         measurementUnit,
         measurementUnitID) %>% 
  drop_na(measurementValue)

write_csv(trawl_emof, here("Trawl", "tidy_data", "trawl_eMoF.csv"))
drive_upload(here("Trawl", "tidy_data", "trawl_emof.csv"),
             path = "https://drive.google.com/drive/folders/1MQ6XJQqnWk2puDaBTfHn7wXITjDSeLR7",
             name = "trawl_eMoF.csv",
             overwrite = TRUE)
```


