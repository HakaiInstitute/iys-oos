---
title: "2019 IYS - Bongo Data wrangle"
author: "Tim van der Stap"
date: "6/17/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lubridate)
library(janitor)
library(readxl)
library(here)
library(parsedate)
library(googledrive)
library(uuid)
library(gtools)
```

The raw data is stored on GoogleDrive. The first step is to download the file from Google Drive to a local folder on your computer's hard drive. 

``` {r file_download, eval = FALSE}
# Make sure your folder path exists already (e.g. ./Bongo/raw_data)
drive_download("https://docs.google.com/spreadsheets/d/1vvIwlsIkuc9vHtVrv2l3pXeyoWpEX_gw/edit#gid=287253584", 
               path = here::here("Bongo", "raw_data", 
                                 "Zoop Bongo Isotopes_IYS_Dry Weight_Mar31.xlsx"),
               overwrite = TRUE)
```

Read in the dataset from your local drive:

``` {r data wrangle, eval = FALSE}
bongo <- read_excel(here("Bongo", "raw_data", 
                       "Zoop Bongo Isotopes_IYS_Dry Weight_Mar31.xlsx"), 
                  sheet = "Samples collected") %>%
  janitor::clean_names() %>%
  # Convert the standalone time value (UTC+12) into ISO8601 extended format
  mutate(Date = lubridate::dmy(date),
         Time = format(start_time, format = "%H:%M:%S"),
         dateTime = format_iso_8601(as.POSIXct(paste(Date, Time), 
                                               format="%Y-%m-%d %H:%M:%S", 
                                               tz="Asia/Kamchatka")),
         dateTime = str_replace(dateTime, "\\+00:00", "Z"),
         cruise = "GoA2019",
         station = paste(cruise, station, sep="_Stn"),
         cast = paste(station, net, sep = ":bongo:Net"),
         sample = paste(cast, sample_id, sep=":")
  )
```

Dataframes are created for each unique `eventID` layer, with unique associated columns. Eventually, the data frames get joined, and the event table gets saved locally and in Google Drive. The column `eventRemarks` is not a required column, and currently only contains descriptive information. However, it is a good method to understand the structure in the dataset. A visual diagram of the structure of the Bongo data set is provided [here](https://app.diagrams.net/#G1YG5AVLwawocrr18XwbZG-1mDwwcc4ewM). 


``` {r bongo_event, eval = FALSE}
bongo_cruise <- bongo %>% 
  select(eventID = cruise) %>%
  distinct(eventID) %>%
  mutate(eventRemarks = "cruise")

bongo_station <- bongo %>%
  select(eventID = station,
         parentEventID = cruise) %>% 
  distinct(eventID, .keep_all = TRUE) %>% 
  mutate(eventRemarks = "station")

# Join date and coordinates to cast (bongo tow)
bongo_cast <- bongo %>%
  select(eventID = cast,
         parentEventID = station,
         eventDate = dateTime,
         decimalLatitude = start_latitude,
         decimalLongitude = start_longitude,
         minimumDepthInMetres = sample_depth,
         maximumDepthInMetres = sample_depth) %>%
  distinct(eventID, .keep_all = TRUE) %>%
  mutate(eventRemarks = "cast")

bongo_sample <- bongo %>%
  select(eventID = sample,
         parentEventID = cast) %>%
  distinct(eventID, .keep_all = TRUE) %>%
  mutate(eventRemarks = "sample")

bongo_event <- bind_rows(bongo_cruise,bongo_station,bongo_cast, bongo_sample) %>% 
  select(eventID, parentEventID:maximumDepthInMetres, eventRemarks) %>%
 mutate(type = "HumanObservation")

# Make sure the folder path exists already (e.g. ./Bongo/tidy_data)
write_csv(bongo_event, here("Bongo", "tidy_data", "bongo_event.csv"))
drive_upload(here("Bongo", "tidy_data", "bongo_event.csv"),
             path = "https://drive.google.com/drive/u/0/folders/1cAJP-DGSQZdRhrIYraX8MJXO-h_7qbn2",
             name = "bongo_event.csv",
             overwrite = TRUE)
```

## Occurrence Core

An `occurrenceID` and `occurrenceStatus` will only be provided to data entries where species have been identified to a level for which we can find a WoRMS taxon. Only for these species can a URN be associated from WoRMS. So first we inspect all the unique input for the `species` column, and filter for all these species by filtering out the species that can _not_ be identified to a species or genus level. Measurements of weight, length, life stage and taxonomic group will still be included, however they will linked directly to the `eventID` (the sampleID) rather than the `occurrenceID`. In other words, these data entries will not be included in the Occurrence Core!

After a brief discussion with Julian, it was agreed on that entries where Species = `Size fraction`, will not have an Occurrence Core associated to it, because it is not possible to associate a URN from WoRMS to this class or group (`Zooplankton`). The same goes for entries where no common rank can be associated, such as `Jellyfish, radiolarian, chaetognath` and `Gelatinous`. For other entries where no clear classification is provided, e.g. `crab zoea` and `jelly mass`, the lowest common rank URN is listed. 

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">
Q: Where do we draw the line when it comes to associating an Occurrence(ID) to an entry? Would this only be for species that have been identified to Species or Genus level, as perhaps a classification on phylum or kingdom level does not really provide any information?
</div>

**A**: After internal discussion, it was opted to associate an occurrence(ID) to an entry as long as we can find a WoRMS taxon / URN, even if a species can only be identified up to a phylum or kingdom level. For data entries where multiple groups are lumped together (i.e. "Jelly fish, radiolarian and chaetognath"), we have opted _not_ to split them into separate occurrenceIDs because it is not possible to associate any measurements to the entry.  

``` {r bongo_occ_pre_wrangle, eval = FALSE}
unique(bongo$species)

# Identify all entries that have not been identified to species or genus level: 
bongo_occ_spp <- bongo %>% filter(!(species %in% c("Size fraction", "Chaetognath & Ctenophore", "Jelly mass",
                                              "Jellyfish, radiolarian, chaetognath", "Gelatinous",
                                              "Ctenophore / jellyfish")))
```

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">
Q: Upon inspection of the species filtered out of the bongo dataset, some sample_ids have associated notes in which sometimes species are specified, see e.g. sample_id Z80, Z15, SS102 etc. Where the notes specify the species and individual measurements (e.g. SS81) I have dealt with these samples in a later stage. However, the other sample_ids I have left as is -- notes are eventually added to the eMoF table in a column labelled measurementRemarks. Would you reckon that is sufficient?

Q: When examining samples SS177, SS178 and SS82, it appears that these data entries have a life stage listed in the species column (hydromedusae and crab zoea). Should we manually make changes in the data to reflect this?
</div>

When examining the bongo_occ_spp dataset, numerous bongo tows have the sample_id 'Petri dish' associated to them, with the only distinguishable feature being a difference in length measurement. In our current set up, all Petri dish sample_ids belong to the same Station have the same sample (GoA2019_Stn10:cast1:bongo:Net1:Petri dish), although they are different data entries. Therefore we attach a unique sample to them and then merge them back to the dataframe: 

``` {r petri_dish, eval = FALSE}
bongo_occ_petri <- bongo_occ_spp %>% filter(sample_id == "Petri dish") %>%
  mutate(sample_id = paste(sample_id, row_number(), sep = "_"))
bongo_occ_spp_temp <- bongo_occ_spp %>% filter(!sample_id == "Petri dish")
bongo_occ_spp <- rbind(bongo_occ_spp_temp, bongo_occ_petri)
```

Upon close inspection of the data entries that we filtered out, there are two sample_ids (SS81 and SS133) for which the species are mentioned in the _notes_ column, _along_ with their length measured. For these two sample_ids we can add an `occurrenceID` and `occurrenceStatus`. Both sample_ids require special attention: For sampleID SS81 the number = 7, but the notes distinguish 8 unique measurements. Additionally, sample_id SS133 requires special attention because although number = 1, in the notes it says that jellies were observed (length range: 10 - 15mm) and 3 sagitta spp. were observed, with individual lengths measured. **For those data entries where some species are specified in the notes but no individual measurements are provided, no additional splitting is done!**

Before creating occurrence tables that will eventually be merged into an Occurrence Core, we will split up the data entries for these two sample_id's, thereby creating unique entries, and join it back with the dataset bongo_occ_spp. To create unique rows for these data entries, we manually change the value in the `number` column. Then we duplicate the row of each sample_id based onthe value in the number column. The newly created dataframe will consist only of the duplicated rows, and will later be merged again with the original dataset. The reason for this is that no weight_mg value is associated to any of the individual measurements (weight_mg = NA).  

``` {r SS81 and SS133, eval = FALSE}
bongo_pre_wrangle <- bongo %>% filter(sample_id %in% c("SS81", "SS133"))

bongo_pre_wrangle$number[1] <- 8
bongo_pre_wrangle$number[2] <- 4

bongo_pre_wrangle_dup <- data.frame(bongo_pre_wrangle[rep(seq_len(dim(bongo_pre_wrangle)[1]),
                                  bongo_pre_wrangle$number), , drop = FALSE], row.names = NULL) %>%
  mutate(weight_mg = NA)

# Merge it back with the original dataframe: 
bongo_pre_wrangle_fnl <- rbind(bongo_pre_wrangle, bongo_pre_wrangle_dup)
bongo_pre_wrangle_fnl$number <- as.numeric(bongo_pre_wrangle_fnl$number)
bongo_pre_wrangle_fnl <- bongo_pre_wrangle_fnl[order(bongo_pre_wrangle_fnl$number, decreasing = TRUE), ]
bongo_pre_wrangle_fnl <- bongo_pre_wrangle_fnl[order(as.character(bongo_pre_wrangle_fnl$sample_id)), ]
bongo_pre_wrangle_fnl$sample_id <- sub('[.]', '_', make.names(bongo_pre_wrangle_fnl$sample_id, unique=TRUE))

# Fill in the unique measurements associated to each data entry. 
bongo_pre_wrangle_fnl <- bongo_pre_wrangle_fnl %>%
  mutate(species = case_when(
    sample_id == "SS133" ~ "Size fraction",
    sample_id == "SS133_1" ~ "Sagitta",
    sample_id == "SS133_2" ~ "Sagitta",
    sample_id == "SS133_3" ~ "Sagitta",
    sample_id == "SS133_4" ~ "jellies",
    sample_id == "SS81_1" ~ "Sagitta",
    sample_id == "SS81" ~ "Size fraction",
    sample_id == "SS81_2" ~ "E pacifica",
    sample_id == "SS81_3" ~ "E pacifica",
    sample_id == "SS81_4" ~ "E pacifica",
    sample_id == "SS81_5" ~ "E pacifica", 
    sample_id == "SS81_6" ~ "E pacifica",
    sample_id == "SS81_7" ~ "T spinifera",
    sample_id == "SS81_8" ~ "T spinifera"))
bongo_pre_wrangle_fnl <- bongo_pre_wrangle_fnl %>% 
  mutate(number = case_when(
    sample_id == "SS133_1" ~ 1,
    sample_id == "SS133_2" ~ 1,
    sample_id == "SS133_3" ~ 1,
    sample_id == "SS133_4" ~ 2,
    sample_id == "SS81_1" ~ 1,
    sample_id == "SS81_2" ~ 1,
    sample_id == "SS81_3" ~ 1,
    sample_id == "SS81_4" ~ 1,
    sample_id == "SS81_5" ~ 1,
    sample_id == "SS81_6" ~ 1,
    sample_id == "SS81_7" ~ 1,
    sample_id == "SS81_8" ~ 1))
bongo_pre_wrangle_fnl <- bongo_pre_wrangle_fnl %>%
  mutate(length_mm = case_when(
    sample_id == "SS133_1" ~ 44,
    sample_id == "SS133_2" ~ 45,
    sample_id == "SS133_3" ~ 48,
    sample_id == "SS133_4" ~ 0, # Find a way to add range 10 - 15mm here.
    sample_id == "SS81_1" ~ 29,
    sample_id == "SS81_2" ~ 14,
    sample_id == "SS81_3" ~ 15,
    sample_id == "SS81_4" ~ 16,
    sample_id == "SS81_5" ~ 17,
    sample_id == "SS81_6" ~ 18,
    sample_id == "SS81_7" ~ 12,
    sample_id == "SS81_8" ~ 13))  
bongo_pre_wrangle_fnl$length_mm[5] <- "10-15mm" 
# This line can be removed if length_mm for SS133_4 can easily be replaced. 

# Add bongo_pre_wrangle_fnl to the dataframe where we filtered out the all entries that have not been identified to species or genus level to obtain the dataset which we'll use to create our occurrence tables and eventually our Occurrence Core. 
bongo_occ_spp <- rbind(bongo_occ_spp, bongo_pre_wrangle_fnl)
```

When examining the remaining data entries in the bongo_occ_spp dataset, we can identify some problems, especially in the columns `number` and `length_mm`. The `number` column indicates the count of a species observed in each trawl, and `count` and `number` will be used synonymous throughout this script. Some problems that we encountered are the following: 

1) Some data entries have counts that are not a specific number (i.e., >3, >4 and >1);
2) Some data entries that have a count > 1, appear to be aggregated entries, as only a single length measurement is associated. However, sometimes individual measurements or classifications are provided in the `notes` column. As we don't want to mess with the raw data .csv file, we have to manually inspect these entries to ensure that no (individual) measurements get overlooked * ;
3) Some data entries have a count > 1, and an associated range in the length measurement (i.e., 15 - 17mm)

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">
Q: If a data entry has number > 1, but only one associated length measurement, does that mean that all individuals in that row have that length? If so perhaps these should all receive a unique `occurrenceID` and `occurrenceStatus`? Right now I haven't split these data entries, but have included a measurement in the eMoF table for "number". 
</div>


__To address these issues, a total of five different occurrence tables will be created, that eventually get merged to a single Occurrence Core! Reminder: in all these occurrence tables only data entries are included where species have been identified to species or genus level, and will therefore have an associated occurrenceID and occurrenceStatus.__

The five Occurrence tables are: 

* bongo_occ1. Occurrence table for entries with no distinct number recorded (i.e., >4, >3 or >1);
* bongo_occ2. Occurrence table for entries where count > 1, but individual measurements (length) are provided in the notes. These entries will be split up and unique `occurrenceID`s will be created;
* bongo_occ3. Occurrence table for entries where count > 1, and a range of length measurements is provided in the `length_mm` column; 
* bongo_occ4. Occurrence table for individual data entries (i.e., where `number` = 1).
* bongo_occ5. Occurrence table for data entries where count > 1, but only a single length measurement is provided. 

These five occurrence tables will eventually be concatenated into a single Occurrence Core. 

***

Let's first examine the data entries where the counts do not have a specific number associated to it. As the species has been identified to a species or genus-level, we do want to assign `occurrenceID` and `occurrenceStatus` columns to them. An `occurrenceID` will be associated at a later stage when all the created occurrence tables are joined. 

``` {r bongo_occ1, eval = FALSE} 
unique(bongo_occ_spp$number)

# This identifies that there are three entries where the number (or count) is not specified: ">1", ">3" and ">4".
bongo_occ1 <- bongo_occ_spp %>% filter(number == ">3" | number == ">4" | number == ">1") %>%
  mutate(occurrenceID = " ",
         occurrenceStatus = "present") %>%
  rename(eventID = sample,
         scientificName = species)
```

Next, we create an occurrence table to address the second issue we are facing, that _some data entries have a count >1, i.e., appear to be aggregated entries_. For some of these data entries, individual measurements or classifications are provided in the `notes` column. Therefore, we need to manually inspect the data entries where number > 1. If individual measurements are provided, we want split the data entry, and associate a unique `occurrenceID` and `occurrenceStatus`. We do _not_ want to create a unique `eventID` for each of these!

We create a separate table for the unique sample_id's that have number > 1 and where the number matches the individual length measurements in `length_mm`. Our intention here is to _add_ duplicate rows for each unique sample_id equal to the value under `number` associated to that data entry. We want to keep the original data entry row (the `eventID`) intact, as this data entry usually contains the weight measurement. In other words, if four individual length measurements are provided in the `length_mm` column, we want to make sure these all get a unique `occurrenceID`, associated to the same `eventID`. 

``` {r bongo_occ2_pre, eval = FALSE}
bongo_occ2 <- bongo_occ_spp %>% filter(number > 1)

# We filter for the sample_ids where number is more than 1, and unique length measurements are provided. . 

bongo_occ2_ind <- bongo_occ2 %>% filter(sample_id %in% c("SS12", "SS38", "SS42B", "22020", "22021",
                                               "SS59", "SS58", "SS57", "SS55", "Z318", "SS68", "SS69",
                                               "SS119", "SS126", "SS176", "SS185"))
```

When filtering for number > 1, we observe that there are data entries for Station 11 that are all for the same species, but unique length measurements are provided for three data entries, and the four includes a length measurement range. We therefore split three of those uniquely created `eventID`s as they have individual measurements associated to them. The fourth uniquely created `eventID` will have number = 3, but only a single length measurement associated. Therefore this row will be removed and be dealt with under bongo_occ3. 

``` {r bongo_occ2_petri, eval = FALSE}
bongo_petri <- bongo_occ2 %>% filter(sample_id == c("Petri dish_13","Petri dish_14", 
                                                    "Petri dish_15", "Petri dish_16"))

bongo_petri <- bongo_petri[-4, ]

# Merge this dataframe back in with the bongo_occ2_ind: 
bongo_occ_new <- rbind(bongo_occ2_ind, bongo_petri)
```

The next step is to create duplicate rows of these data entries, equal to the count in the `number` column. These duplicated rows will need to reflect the individual length (mm) measurements and also reflect that it now represents just a single measurement (i.e., number = 1). For all the split unique data entries in this dataframe, the weight_mg measurement will be NA. The weight_mg measurements for these data entries combined will still be reflected in the original data. In a later stage, this newly created dataframe will be merged with the original dataframe. 

``` {r bongo_occ2_wrangle, eval = FALSE}
bongo_occ2dup <- data.frame(bongo_occ_new[rep(seq_len(dim(bongo_occ_new)[1]),
                                                       bongo_occ_new$number), ,
                                    drop = FALSE], row.names = NULL) %>%
  mutate(number = 1)

bongo_occ2dup$weight_mg <- ifelse(bongo_occ2dup$weight_mg == "TBD", "TBD", NA)

bongo_occ2 <- rbind(bongo_occ_new, bongo_occ2dup)
bongo_occ2$number <- as.numeric(bongo_occ2$number)
bongo_occ2 <- bongo_occ2[order(bongo_occ2$number, decreasing = TRUE), ]
bongo_occ2 <- bongo_occ2[order(as.character(bongo_occ2$sample_id)), ]
bongo_occ2$sample_id <- sub('[.]', '_', make.names(bongo_occ2$sample_id, unique=TRUE))
# For some reason this adds an X for sample_id 22020 and 22021 so this needs to get removed: 
bongo_occ2$sample_id <- gsub("X", "", bongo_occ2$sample_id)

# Now we have both the original data entry and duplicated rows in a dataframe. The only things that needs to be changed in the dataframe is the length measurements within the duplicated rows, to reflect the individual measurements. I am unsure if there is a faster way to do this, but a cumbersome way is: 

bongo_occ2 <- bongo_occ2 %>% 
 mutate(length_mm = case_when(
    sample_id == "Petri_dish_13.1" ~ 70,
    sample_id == "Petri_dish_13.2" ~ 65,
    sample_id == "Petri_dish_13.3" ~ 55,
    sample_id == "Petri_dish_14.1" ~ 60,
    sample_id == "Petri_dish_14.2" ~ 60,
    sample_id == "Petri_dish_14.3" ~ 55,
    sample_id == "Petri_dish_15.1" ~ 55,
    sample_id == "Petri_dish_15.2" ~ 50,
    sample_id == "Petri_dish_15.3" ~ 50,
    sample_id == "Petri_dish_15.4" ~ 45,
    sample_id == "22020_1" ~ 20,
    sample_id == "22020_2" ~ 19,
    sample_id == "22020_3" ~ 15,
    sample_id == "22021_1" ~ 10,
    sample_id == "22021_2" ~ 16,
    sample_id == "22021_3" ~ 16,
    sample_id == "SS119_1" ~ 11,
    sample_id == "SS119_2" ~ 12,
    sample_id == "SS119_3" ~ 14,
    sample_id == "SS119_4" ~ 15,
    sample_id == "SS12_1" ~ 12,
    sample_id == "SS12_2" ~ 13,
    sample_id == "SS126_1" ~ 15,
    sample_id == "SS126_2" ~ 12,
    sample_id == "SS176_1" ~ 37,
    sample_id == "SS176_2" ~ 41,
    sample_id == "SS176_3" ~ 34,
    sample_id == "SS176_4" ~ 42,
    sample_id == "SS185_1" ~ 15,
    sample_id == "SS185_2" ~ 22,
    sample_id == "SS38_1" ~ 14,
    sample_id == "SS38_2" ~ 23,
    sample_id == "SS42B_1" ~ 17,
    sample_id == "SS42B_2" ~ 25,
    sample_id == "SS55_1" ~ 30,
    sample_id == "SS55_2" ~ 21,
    sample_id == "SS55_3" ~ 22,
    sample_id == "SS55_4" ~ 24,
    sample_id == "SS57_1" ~ 13,
    sample_id == "SS57_2" ~ 13,
    sample_id == "SS57_3" ~ 14,
    sample_id == "SS57_4" ~ 14,
    sample_id == "SS58_1" ~ 17,
    sample_id == "SS58_2" ~ 18,
    sample_id == "SS58_3" ~ 21,
    sample_id == "SS59_1" ~ 12,
    sample_id == "SS59_2" ~ 12,
    sample_id == "SS59_3" ~ 13, 
    sample_id == "SS59_4" ~ 14,
    sample_id == "SS59_5" ~ 14,
    sample_id == "SS59_6" ~ 14,
    sample_id == "SS68_1" ~ 15,
    sample_id == "SS68_2" ~ 16,
    sample_id == "SS68_3" ~ 17,
    sample_id == "SS69_1" ~ 12,
    sample_id == "SS69_2" ~ 13,
    sample_id == "SS69_3" ~ 14, 
    sample_id == "SS69_4" ~ 17,
    sample_id == "Z318_1" ~ 35,
    sample_id == "Z318_2" ~ 40
  )) %>%
 # filter only for the entries where number = 1 
 filter(number == 1) %>%
  mutate(occurrenceStatus = ifelse(number > 0, "present", "absent"),
         occurrenceID = " ") %>%  
  rename(eventID = sample,
         scientificName = species)
```

Third, we create an occurrence table for the third issue, _some data entries have a count > 1, and an associated range in the length measurement (i.e., 15 - 17mm)_. The next chunk of code is for the data entries where number > 1, _but_ no distinct measurement lengths are provided, but a range is provided. In the code above, these entries were _not_ given an occurrenceID (but the individual measurements were); however, here we do provide an `occurrenceID` for these entries, and in the eMoF table they will have measurementTypes `minimum length` and `maximum length` to display the range. As these are all ranged values, all entries contain a hyphen so we can filter for that. 

``` {r occ_range, eval = FALSE}
# From the original dataset, filter out all the numbers in the `length_mm` column that contain a range (i.e., a -). 
bongo_occ3 <- bongo_occ_spp %>% 
  filter(grepl("-", bongo_occ_spp$length_mm)) %>%
  mutate(occurrenceID = " ",
         occurrenceStatus = "present") %>%
  rename(eventID = sample, 
         scientificName = species)
```

So far, for all the data entries where species have been identified to a species or genus level, we've created occurrence tables for: 

    *- Data entries where the number is not a specific number (i.e., >3, >4 and >1)
    *- Data entries where number > 1 and individual measurements are depicted in the notes
    *- Data entries where number > 1 and a range is provided in the `length_mm` column. 
    
This leaves two occurrence tables that need to be created:

1) all data entries where species or genus has been identified and individual measurements are associated (i.e., the rows where number = 1), and;
2) all data entries where species or genus has been identified and the number is greater than 1, but only a _single_ length measurement is provided.  

``` {r bongo_occ_ind, eval = FALSE}
bongo_occ4 <- bongo_occ_spp %>%
  filter(number == 1) %>%
  filter(!sample_id %in% c("22003", "Z372")) %>%
  
# Upon inspection, bongo_occ4 has sample_id 22003 and Z372 as well. These is a samples where number = 1, but the length measurement is a range. Therefore, these samples are already included in bongo_occ3 dataset and are therefore omitted from this dataset. 
  
  mutate(occurrenceID = " ",
         occurrenceStatus = "present") %>%
  rename(eventID = sample,
         scientificName = species)
```

There are also data entries where the species have been identified to a species or genus level, and where the number > 1, but no individual length measurements (or range) is associated with it. We will also associate an `occurrenceID` and `occurrenceStatus` to these species, and in the extended measurementOrFact table the number (count) will be linked to the `occurrenceID` as a measurement.

``` {r bongo_occ5, eval = FALSE}
bongo_occ5 <- bongo_occ_spp %>%
  filter(number > 1)
# Remove the rows where sample_id matches with those in bongo_occ3 (where length_mm have ranged value)
bongo_occ5 <- bongo_occ5[ !(bongo_occ5$sample_id %in% bongo_occ3$sample_id), ] 
# Remove the rows where sample_id matches with those in bongo_occ2 (where individual length measurements have been recorded in the notes)
bongo_occ5 <- bongo_occ5[ !(bongo_occ5$sample_id %in% bongo_occ2_ind$sample_id), ]
# Remove the rows where sample_id matches with those in bongo_petri (dataframe of petri dish with individual length measurements)
bongo_occ5 <- bongo_occ5[ !(bongo_occ5$sample_id %in% bongo_petri$sample_id), ] %>%
  mutate(occurrenceID = " ",
         occurrenceStatus = "present") %>%  
  rename(eventID = sample,
         scientificName = species)
```

To create the final occurrence table, the five occurrence tables are joined. As individual measurements are associated to these data entries, an `occurrenceID` is created for them. Additionally, for each species the proper scientificNameID (WoRMS URN) is provided. 

``` {r bongo_combined_occ, eval = FALSE}
# Next, combine bongo_occ_wr with the original dataframe (bongo)
bongo_occ_fnl <- rbind(bongo_occ1, bongo_occ2, bongo_occ3, bongo_occ4, bongo_occ5) 
bongo_occ_fnl <- bongo_occ_fnl[mixedorder(as.character(bongo_occ_fnl$eventID)),]
bongo_occ_fnl <- bongo_occ_fnl %>%
  mutate(occurrenceID = paste("IYS_GoA2019_zocc", row_number(), sep = ""),
  scientificNameID = case_when(
      scientificName == "Thysanoessa spinifera" ~ "urn:lsid:marinespecies.org:taxname:237874", 
      scientificName == "Sergestes similis" ~ "urn:lsid:marinespecies.org:taxname:514127",
      # Accepted name is Eusergestes similis
      scientificName == "Euphausia pacifica" ~ "urn:lsid:marinespecies.org:taxname:237851",
      scientificName == "Salpa aspera" ~ "urn:lsid:marinespecies.org:taxname:137270",
      scientificName == "Copepod" ~ "urn:lsid:marinespecies.org:taxname:1080",
      # Subclass: Copepoda
      scientificName == "Neocalanus cristatus" ~ "urn:lsid:marinespecies.org:taxname:104470" ,
      scientificName == "Cyphocaris" ~ "urn:lsid:marinespecies.org:taxname:101603",
      scientificName == "Squat lobster" ~ "urn:lsid:marinespecies.org:taxname:106671",
      # Unsure whether the squat lobster is part of the superfamily Chirostyloidea or Galatheoidea, so the lowest common rank (InfraOrder) of Anomura was chosen. 
      scientificName == "Siphonophore" ~ "urn:lsid:marinespecies.org:taxname:1371",
      scientificName == "Chaetognath (Sagitta)" ~ "urn:lsid:marinespecies.org:taxname:5949",
      # Chaetognatha - class: Sagittoidea
      scientificName == "Beroe sp." ~ "urn:lsid:marinespecies.org:taxname:1434803",
      scientificName == "Euphausiid" ~ "urn:lsid:marinespecies.org:taxname:110671",
      # Family: Euphasiidae
      scientificName == "Siphonophore (Lensia type)" ~ "urn:lsid:marinespecies.org:taxname:135365",
      scientificName == "Aequorea sp." ~ "urn:lsid:marinespecies.org:taxname:116998",
      scientificName == "Radiolarians" ~ "urn:lsid:marinespecies.org:taxname:582421",
      # Phylum: Radiozoa
      scientificName == "Paraphronima (gracilis)" ~ "urn:lsid:marinespecies.org:taxname:236597",
      scientificName == "Microstomus pacificus" ~ "urn:lsid:marinespecies.org:taxname:274294",
      scientificName == "Thysanoessa (longipes)" ~ "urn:lsid:marinespecies.org:taxname:237873",
      scientificName == "Myctophid larva" ~ "urn:lsid:marinespecies.org:taxname:125498",
      # Family: Myctophidae
      scientificName == "Primno pacifica" ~ "urn:lsid:marinespecies.org:taxname:286539",
      # Genus: Primnoa
      scientificName == "Japatella diaphana" ~ "urn:lsid:marinespecies.org:taxname:138849",
      # Genus: Japetella
      scientificName == "Clio pyrimidata" ~ "urn:lsid:marinespecies.org:taxname:139033",
      # Species: Clio pyramidata
      scientificName == "Paraeuchaeta sp." ~ "urn:lsid:marinespecies.org:taxname:196874",
      scientificName == "Thysanoessa sp." ~ "urn:lsid:marinespecies.org:taxname:110679",
      scientificName == "Gastropod veliger" ~ "urn:lsid:marinespecies.org:taxname:101",
      # Class: Gastropoda - veliger are the planktonic larvae
      scientificName == "Tarletonbeania crenularis" ~ "urn:lsid:marinespecies.org:taxname:282927",
      scientificName == "Limacina helicina" ~ "urn:lsid:marinespecies.org:taxname:140223",
      scientificName == "Phronima (sedentaria)" ~ "urn:lsid:marinespecies.org:taxname:103272",
      scientificName == "Hydromedusae" ~ "urn:lsid:marinespecies.org:taxname:1337",
      # Hydromedusae belong to the Hydrozoa as a sub-class, along with the Scyphomedusae. In WoRMS, the closest accepted URN I could find is that for subclass "Hydroidolina". As I'm not sure if this is the correct one, currently the URN for Hydromedusae reflects the URN for Hydrozoa. 
      scientificName == "Siphonophore" ~ "urn:lsid:marinespecies.org:taxname:1371",
      scientificName == "siphonophore" ~ "urn:lsid:marinespecies.org:taxname:1371",
      # Order: Siphonophorae
      scientificName == "Sagitta" ~ "urn:lsid:marinespecies.org:taxname:105410", 
      scientificName == "E pacifica" ~ "urn:lsid:marinespecies.org:taxname:237851",
      scientificName == "T spinifera" ~ "urn:lsid:marinespecies.org:taxname:237874",
      scientificName == "Crab zoea" ~ "urn:lsid:marinespecies.org:taxname:1130"
    )
  )
bongo_occ_core <- bongo_occ_fnl %>%
  rename(Preparations = preservation) %>%
  select(eventID, occurrenceID, scientificName, scientificNameID, occurrenceStatus, Preparations)
# I change bongo_occ_fnl into a new dataframe because we're going to use the bongo_occ_fnl dataset in the eMoF table.

# Make sure the folder path exists already (e.g. ./Bongo/tidy_data)
write_csv(bongo_occ_core, here("Bongo", "tidy_data", "bongo_occ.csv"))
drive_upload(here("Bongo", "tidy_data", "bongo_occ.csv"),
             path = "https://drive.google.com/drive/u/0/folders/1cAJP-DGSQZdRhrIYraX8MJXO-h_7qbn2",
             name = "bongo_occ.csv",
             overwrite = TRUE)
```

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">
Q: All species that are listed as `size fraction` belong to the group "Zooplankton". How can we best represent this group according to OBIS / WoRMS standards?
A: As no species name or genus is provided, rather than creating an `occurrenceID` for these species, we link the measurements associated to this data entry directly to the `eventID`. To indicate that it does concern measurements associated to 'Zooplankton', one of the measurement parameters is the column `Group`. 
</div>

## extended measurementOrFact

In our extended measurementOrFact table(s), we associate the measurements to either the `eventID` (if species was not identified to species or genus level), or the `occurrenceID` (if species was identified to species or genus level). As a first step though, we associate the _seafloor depth_ and _sampling depth_ to the cast. 

``` {r bongo_bottomdepth, eval = FALSE}
bongo_bottomdepth <- bongo %>% 
  select(eventID = cast, 
         depth, sample_depth) %>%
  distinct(eventID, .keep_all = TRUE) %>%
  mutate_all(as.character) %>%
  pivot_longer(cols = depth:sample_depth,
               names_to = "measurementType",
               values_to = "measurementValue") %>%
  mutate(measurementID = case_when(
    measurementType == "depth" ~ paste(eventID, "depth", sep = ":"),
    measurementType == "sample_depth" ~ paste(eventID, "sample_depth", sep = ":")),
        measurementType = recode(measurementType,
                                 depth = "seafloor depth",
                                 sample_depth = "sampling depth")) %>%
  mutate(measurementTypeID = case_when(
    measurementType == "seafloor depth" ~ "http://vocab.nerc.ac.uk/collection/C00/current/SCILOG/",
    measurementType == "sampling depth" ~ "http://vocab.nerc.ac.uk/collection/P01/current/DXPHPRST/"),
        measurementUnit = case_when(
    measurementType == "seafloor depth" ~ "m",
    measurementType == "sampling depth" ~ "m"),
        measurementUnitID = case_when(
    measurementUnit == "m" ~ "http://vocab.nerc.ac.uk/collection/P06/current/ULAA/")) %>%
  select(eventID, measurementID, measurementType, measurementTypeID, measurementValue, 
         measurementUnit, measurementUnitID)
```

Though an occurrenceID was not created for each data entry, measurements can be linked either directly to the `eventID` or to the `occurrenceID`. The following measurements are linked to either the `eventID` or `occurrenceID`: `length_mm`, `length_type`, `weight_mg`, `number` and `(taxonomic) group`. Additional information that might in the future be included as well could be `Stage`, which reflects a lifeStage of an organism. However, because the datasheet includes a wide variety of organisms, all with different 'levels' of a life stage, to what extent is it necessary to choose a uniform 'coding' system for this variable? Finally, `size_fraction` needs to be added to `eventID`, but perhaps also to the `occurrenceID`. 

We first create the eMoF table that links directly to the `eventID`. First we have to filter for all the data entries for which no `occurrenceID` has been created. In other words, remove any rows (data entries) for which an `occurrenceID` has been created:

``` {r eMoF, eval = FALSE}
bongo_occID <- bongo_occ_fnl %>% rename(sample = eventID)
bongo_emof <- bongo[ !(bongo$sample %in% bongo_occID$sample), ]

# Upon visual inspection of the bongo_emof dataset, this does include only data entries for species that have not been identified to a species or genus level, including the species that's only listed as 'size_fraction'. 

bongo_emof <- bongo_emof %>%
  select(eventID = sample, 
         number, size_fraction, 
         length = length_mm,
         weight = weight_mg,
         length_type,
         group) %>%

  # As there is no NERC vocab (it appears) for milligram (for the weight), we transform this column to reflect the weight in grams: 
  mutate(weight = as.numeric(weight) / 1000) %>%
  mutate_all(as.character) %>%
  pivot_longer(cols = number:group, 
               names_to = "measurementType",
               values_to = "measurementValue") %>%
  mutate(
    measurementID = case_when(
      measurementType == "number" ~ paste(eventID, "number", sep = ":"),
      measurementType == "size_fraction" ~ paste(eventID, "size_fraction", sep = ":"),
      measurementType == "length" ~ paste(eventID, "length", sep = ":"),
      measurementType == "length_type" ~ paste(eventID, "length_type", sep = ":"),
      measurementType == "weight" ~ paste(eventID, "weight", sep = ":"),
      # Have to check whether this is dry weight or wet weight. 
      measurementType == "group" ~ paste(eventID, "taxonomic group", sep = ":")
    ),
    measurementTypeID = case_when(
      measurementType == "number" ~ "http://vocab.nerc.ac.uk/collection/S06/current/S0600008/",
      measurementType == "size_fraction" ~ "http://vocab.nerc.ac.uk/collection/P01/current/MSHSIZE1/",
      # samplingProtocol
      measurementType == "length" ~ "http://vocab.nerc.ac.uk/collection/S06/current/S0600015/",
      # I want to check if maybe there is a better Controlled Vocab for body size
      measurementType == "length_type" ~ "http://vocab.nerc.ac.uk/collection/P01/current/OBSINDLX/",
      measurementType == "weight" ~ "http://vocab.nerc.ac.uk/collection/S06/current/S0600087/",
      # As per communication with Brian Hunt: weight refers to net dry weight!
      measurementType == "group" ~ "http://vocab.nerc.ac.uk/collection/P01/current/SCNAME01/"
    ), 
    measurementUnit = case_when(
      measurementType == "number" ~ "individuals",
      measurementType == "length" ~ "mm",
      measurementType == "weight" ~ "g",
      measurementType == "size_fraction" ~ "mm" 
      # If this is equal to mesh size
    ), 
    measurementUnitID = case_when(
      measurementUnit == "individuals" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UUUU/", 
      measurementUnit == "mm" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UXMM/",
      measurementUnit == "g" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UGRM/",
      # Reminder: there is no NERC Controlled Vocabulary for mg, so values are formatted to 'grams'. 
    )
    )
```

When the species or genus has been identified, the measurements are associated to the occurrenceID. The reason for this is that URNs from [WoRMS](http://www.marinespecies.org/) can be associated to the species entries. For the entries where the `Species` are more descriptive or which haven't been able to get associated to a URN from WoRMS, the measurements are linked directly to the `eventID`. This concerns the following listed "Species": `Gelatinous`, `Jellyfish, radiolarian, chaetognath`, and `size fraction`. 

``` {r, eval = FALSE}
bongo_emof2 <- bongo_occ_fnl %>%
  select(eventID, occurrenceID,
         number, size_fraction,
         length = length_mm,
         weight = weight_mg,
         length_type,
         stage,
         group) %>%
  mutate(weight = as.numeric(weight) / 1000) %>% 
  mutate_all(as.character)
```

Within this dataframe, there are still the data entries that have a length measurements associated to them that's a range (i.e., 15 - 17mm). For these `occurrenceID`s we want to split this column into two, with minimumLength and maximumLength. Afterwards, that dataframe can be merged back in with bongo_emof2. 

``` {r, eval = FALSE}
range <- bongo_emof2 %>%
  # bongo_emof2 needs to be replaced with a table that contains the occurrenceIDs!!
  filter(grepl("-", bongo_emof2$length)) %>%
  separate(length, c("minimumLength", "maximumLength")) %>%
  mutate(length = " ")
range$maximumLength <- gsub("mm", "", range$maximumLength) 

# Remove any rows from bongo_emof2 where length_mm contains a range, add two dummy columns (minimumLength and maximumLength) and use rbind() to merge `range` with this newly created dataframe.

temp <- bongo_emof2[ -grep("-", bongo_emof2$length), ] %>%
  mutate(minimumLength = " ",
         maximumLength = " ")

bongo_emof2 <- rbind(range, temp)
```

So now we have a dataframe where:
    * - Species have been identified to a species or genus level
    * - Length measurement ranges have been split up into columns of minimumLength and maximumLength.
    
``` {r, eval = FALSE}
bongo_emof2 <- bongo_emof2 %>%
  mutate_all(as.character) %>%
  pivot_longer(cols = number:length, 
               names_to = "measurementType",
               values_to = "measurementValue") %>%
  mutate(
    measurementID = case_when(
      measurementType == "number" ~ paste(eventID, "number", sep = ":"),
      measurementType == "size_fraction" ~ paste(eventID, "size_fraction", sep = ":"),
      measurementType == "length" ~ paste(eventID, "length", sep = ":"),
      measurementType == "length_type" ~ paste(eventID, "length_type", sep = ":"),
      measurementType == "weight" ~ paste(eventID, "weight", sep = ":"),
      # Have to check whether this is dry weight or wet weight. 
      measurementType == "group" ~ paste(eventID, "taxonomic group", sep = ":"),
      measurementType == "maximumLength" ~ paste(eventID, "maxLength", sep = ":"),
      measurementType == "minimumLength" ~ paste(eventID, "minLenght", sep = ":")
    ),
    measurementValueID = case_when(
      measurementValue == "Copepod" ~ "urn:lsid:marinespecies.org:taxname:1080",
      measurementValue == "Chaetognath" ~ "urn:lsid:marinespecies.org:taxname:2081",
      measurementValue == "Siphonphore" ~ "urn:lsid:marinespecies.org:taxname:1371",
      measurementValue == "Euphausiid" ~ "urn:lsid:marinespecies.org:taxname:110671",
      measurementValue == "Zooplankton" ~ " ",
      measurementValue == "Pteropod" ~ "urn:lsid:marinespecies.org:taxname:325345",
      measurementValue == "Decapod" ~ "urn:lsid:marinespecies.org:taxname:1130",
      measurementValue == "Tunicate" ~ "urn:lsid:marinespecies.org:taxname:146420",
      measurementValue == "Amphipod" ~ "urn:lsid:marinespecies.org:taxname:1135",
      measurementValue == "Ctenophore" ~ "urn:lsid:marinespecies.org:taxname:1248",
      measurementValue == "Hydromedusae" ~ "urn:lsid:marinespecies.org:taxname:1337",
      # Hydromedusae is a life stage of Hydrozoa (URN provided)
      measurementValue == "Fish" ~ "urn:lsid:marinespecies.org:taxname:11676",
      measurementValue == "Squid" ~ "urn:lsid:marinespecies.org:taxname:11707",
      measurementValue == "Gastropod" ~ "urn:lsid:marinespecies.org:taxname:101"
    ),
    measurementValueID = case_when(
      measurementValue == "NA" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1131/",
      measurementValue == "2" ~ " ",
      measurementValue == "4" ~ " ",
      measurementValue == "1to2" ~ " ",
      # Perhaps http://vocab.nerc.ac.uk/collection/S11/current/S1165/ is appropriate?
      measurementValue == "CV" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1112/",
      # Assuming that CV represents C5.
      measurementValue == "Spent" ~ " ",
      measurementValue == "Solitary" ~ " ",
      measurementValue == "juvenile" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1127/",
      measurementValue == "Gravid female" ~ " "
      ),
    measurementTypeID = case_when(
      measurementType == "number" ~ "http://vocab.nerc.ac.uk/collection/S06/current/S0600008/",
      measurementType == "size_fraction" ~ "http://vocab.nerc.ac.uk/collection/P01/current/MSHSIZE1/",
      # samplingProtocol
      measurementType == "length" ~ "http://vocab.nerc.ac.uk/collection/P01/current/OBSINDLX/",
      # I want to check if maybe there is a better Controlled Vocab for body size
      measurementType == "maximumLength" ~ "http://vocab.nerc.ac.uk/collection/P01/current/OBSMAXLX/",
      measurementType == "minimumLength" ~ "http://vocab.nerc.ac.uk/collection/P01/current/OBSMINLX/",
      measurementType == "length_type" ~ "http://vocab.nerc.ac.uk/collection/P01/current/OBSINDLX/",
      measurementType == "weight" ~ "http://vocab.nerc.ac.uk/collection/S06/current/S0600253/",
      # As per communication with Brian Hunt: weight refers to net dry weight!
      measurementType == "group" ~ "http://vocab.nerc.ac.uk/collection/P01/current/SCNAME01/"
    ), 
    measurementUnit = case_when(
      measurementType == "number" ~ "individuals",
      measurementType == "length" ~ "mm",
      measurementType == "minimumLength" ~ "mm",
      measurementType == "maximumLength" ~ "mm",
      measurementType == "weight" ~ "g",
      measurementType == "size_fraction" ~ "mm" 
      # If this is equal to mesh size
    ), 
    measurementUnitID = case_when(
      measurementUnit == "individuals" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UUUU/",
      measurementUnit == "mm" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UXMM/",
      measurementUnit == "g" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UGRM/"
      # Reminder: there is no NERC Controlled Vocabulary for mg, so values are formatted to 'grams'. 
      # Reminder2: The size_fraction is often times measured in microns, but in the data set it is reported in 'mm', 
      # or 1/1000th of a micron. 
      # The measurementUnitID for microns, if needed, is: http://vocab.nerc.ac.uk/collection/P06/current/UMIC/
    )
    )
```

As there were also comments in the dataset, we have to make sure we include those in the measurementOrFact table, as they might be important to the measurements. Additionally, as there is NERC vocabulary for the different length types in this dataset, we include this column in the measurementRemarks, alongside the original notes. 

``` {r measurementRemarks, eval = FALSE}
bongo_measurementRemarks <- bongo %>%
  select(eventID = sample, length_type, notes)
bongo_measurementRemarks <- bongo_measurementRemarks %>%
  mutate(notes = paste(notes, "Length type", sep = ". "),
         notes = paste(notes, length_type, sep = ": "))

# As not all data entries had a comment, some were left with NA. This string needs to be removed.

bongo_measurementRemarks$notes <- gsub("NA. ", "", bongo_measurementRemarks$notes)
bongo_measurementRemarks <-  bongo_measurementRemarks %>%
  select(eventID, notes) %>% 
  pivot_longer(cols = notes, values_to = "measurementRemarks") %>%
  mutate(measurementID = case_when(
    name == "notes" ~ paste(eventID, "notes", sep = ":"))) %>%
  select(measurementID, measurementRemarks)
```

Finally, join all the tables together to form the measurementOrFact Core, and save it locally and on GoogleDrive: 

``` {r bongo_measurementOrFact Core, eval = FALSE}
bongo_measurementOrFact <- bind_rows(bongo_bottomdepth, bongo_emof, bongo_emof2) %>%
  left_join(bongo_measurementRemarks) %>%
  select(
    eventID,
    occurrenceID,
    measurementID,
    measurementType,
    measurementTypeID,
    measurementValue,
    measurementValueID,
    measurementUnit,
    measurementUnitID,
    measurementRemarks)

# If you want to change the order of the eventID, use:
bongo_measurementOrFact <- bongo_measurementOrFact[mixedorder(as.character(bongo_measurementOrFact$eventID)),]
# I personally like this to QC my data manually. 

# Make sure the folder path exists already (e.g. ./Bongo/tidy_data)
write_csv(bongo_measurementOrFact, here("Bongo", "tidy_data", "bongo_emof.csv"))
drive_upload(here("Bongo", "tidy_data", "bongo_emof.csv"),
             path = "https://drive.google.com/drive/u/0/folders/1cAJP-DGSQZdRhrIYraX8MJXO-h_7qbn2",
             name = "bongo_emof.csv",
             overwrite = TRUE)
```
