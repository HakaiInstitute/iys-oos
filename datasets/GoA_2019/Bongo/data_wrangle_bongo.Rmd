---
title: "2019 IYS - Bongo Data wrangle"
author: "Tim van der Stap"
date: "6/17/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lubridate)
library(janitor)
library(readxl)
library(here)
library(parsedate)
library(googledrive)
library(uuid)
```

The raw data is stored on GoogleDrive. The first step is to download the file from Google Drive to a local folder on your computer's hard drive. 

``` {r file_download, eval = FALSE}
# Make sure your folder path exists already (e.g. ./Bongo/raw_data)
drive_download("https://docs.google.com/spreadsheets/d/1vvIwlsIkuc9vHtVrv2l3pXeyoWpEX_gw/edit#gid=287253584", 
               path = here::here("Bongo", "raw_data", 
                                 "Zoop Bongo Isotopes_IYS_Dry Weight_Mar31.xlsx"),
               overwrite = TRUE)
```


``` {r data wrangle, eval = FALSE}
bongo <- read_excel(here("Bongo", "raw_data", 
                       "Zoop Bongo Isotopes_IYS_Dry Weight_Mar31.xlsx"), 
                  sheet = "Samples collected") %>%
  janitor::clean_names() %>%
  # Convert the standalone time value (UTC+12) into ISO8601 extended format
  mutate(Date = lubridate::dmy(date),
         Time = format(start_time, format = "%H:%M:%S"),
         dateTime = format_iso_8601(as.POSIXct(paste(Date, Time), 
                                               format="%Y-%m-%d %H:%M:%S", 
                                               tz="Asia/Kamchatka")),
         dateTime = str_replace(dateTime, "\\+00:00", "Z"),
         cruise = "GoA2019",
         station = paste(cruise, station, sep="_Stn"),
         cast = paste(station, "cast1", sep=":"),
         ndepth = paste(cast, net, sep = ":bongo:Net"),
         sample = paste(ndepth, sample_id, sep=":")
  )
```

``` {r bongo_event, eval = FALSE}
bongo_cruise <- bongo %>% 
  select(eventID = cruise) %>%
  distinct(eventID) %>%
  mutate(eventRemarks = "cruise")

bongo_station <- bongo %>%
  select(eventID = station,
         parentEventID = cruise) %>% 
  distinct(eventID, .keep_all = TRUE) %>% 
  mutate(eventRemarks = "station")

# Join date and coordinates to cast
bongo_cast <- bongo %>%
  select(eventID = cast,
         parentEventID = station,
         eventDate = dateTime,
         decimalLatitude = start_latitude,
         decimalLongitude = start_longitude) %>%
  distinct(eventID, .keep_all = TRUE) %>%
  mutate(eventRemarks = "cast")

bongo_ndepth <- bongo %>% 
  select(eventID = ndepth,
         parentEventID = cast,
         minimumDepthInMetres = sample_depth,
         maximumDepthInMetres = sample_depth) %>% 
  distinct(eventID, .keep_all = TRUE) %>% 
  mutate(eventRemarks = "sample")

bongo_sample <- bongo %>%
  select(eventID = sample,
         parentEventID = ndepth) %>%
  distinct(eventID, .keep_all = TRUE) %>%
  mutate(eventRemarks = "subsample")

bongo_event <- bind_rows(bongo_cruise,bongo_station,bongo_cast,bongo_ndepth,bongo_sample) %>%   select(eventID, parentEventID:maximumDepthInMetres, eventRemarks) %>%
 mutate(type = "HumanObservation")

# Make sure the folder path exists already (e.g. ./Bongo/tidy_data)
write_csv(bongo_event, here("Bongo", "tidy_data", "bongo_event.csv"))
drive_upload(here("Bongo", "tidy_data", "bongo_event.csv"),
             path = " ",
             name = "bongo_event.csv",
             overwrite = TRUE)
```

## Occurrence Core

The column `Number` indicates how often a species was (en)countered in each specific trawl. Some species have counts that are not a specific number (i.e., >3, >4, ~3 and >1). We assume these species, that have often not been identified to a species level, also have to be included in the list of species present.

When examining this dataset, we can identify entries that we need to be explored further, because the number != 1. However, as the number > 0, they will have an associated measurementOrFact table. Some of these data entries, where number > 0, are aggregated entries - and contain individual measurements of the species in either the `Length (mm)` column or in the `notes`. As these data entries contain individual measurements, we would want to create unique `eventID`s for them. First we have to manually search for them: 

``` {r occ_number, eval = FALSE}
bongo_number <- bongo %>% filter(number > 1 | number == ">3" | number == ">4" |
                                 number == "~3" | number == ">1") %>%
```

This shows there are 128 obs., that we have to inspect manually. Upon manual inspection, there are _n = 20_ where the individual length measurements are written out in the column `Length (mm)`, _and_ the amount of individual measurements matches the value in the `number` column. Four of these entries have sample_id `Petri dish` and we will deal with these in another chunk of code (see below). 

We create a separate table for the unique sample_id's that have number > 1 and where the number matches the individual length measurements in `length_mm`. Our intention here to _add_ duplicate rows for each unique sample_id equal to the value under `number` associated to that data entry. However, we want to keep the original data entry row (the `eventID`) intact. In other words, if the `eventID` indicates e.g. four individual length measurements in the `length_mm` column, we want to make sure these all get a unique `occurrenceID`. 

We're going to make _four_ occurrence tables that we'll combine to one Occurrence Core: 

1. One table where we _create_ unique occurrenceIDs for the `eventIDs` where distinct measurements have been recorded in the `length_mm` column. 
2. One table where we _create_ unique occurrenceIDs for the `eventIDs` where a range is recorded in the `length_mm` column, e.g. 15-17mm. The measurementOrFact table for these occurrenceIDs will include maximum and minimum length.
3. When `number` > 1, but no unique measurement lengths are provided. It is needed that the species is has been identified to species or genus level. 
4. Finally, one table for all individual data entries (i.e., where `number` = 1). 

In other words, not all data entries (rows) get an associated `occurrenceID` or `occurrenceStatus`. The exceptions are: 
1. When no specific species name is provided in the `species` column and the genus or phylum can not be distinguished from the `Group` column, nor from the notes. An example of this would be e.g. where `species` = Size fraction; 
2. When no absolute or ranged length measurements or numbers are provided (e.g. >3, ~3);

Though no `occurrenceID` or `occurrenceStatus` is associated, this does not mean that no measurements will be linked.

``` {r occ_number_length, eval = FALSE}
bongo_number_length <- bongo_number %>% filter(sample_id %in% c(
                                               "SS12", "SS38", "SS42B", "22020", "22021",
                                               "SS59", "SS58", "SS57", "SS55", "Z318", "SS68", "SS69",
                                               "SS119", "SS126", "SS176", "SS185", "SS81"))
bongo_pre_wrangle<- data.frame(bongo_number_length[rep(seq_len(dim(bongo_number_length)[1]),
                                                       bongo_number_length$number), ,
                                    drop = FALSE], row.names = NULL) %>% 
  mutate(number = 1)
bongo_pre_wrangle$weight_mg <- ifelse(bongo_pre_wrangle$weight_mg == "TBD", "TBD", NA)

# These duplicated rows will need to reflect the individual length (mm) measurements and also reflect that it now represents just a single measurement (i.e., number = 1). Additionally, for all the split unique eventIDs in this dataframe, the weight_mg measurement has to be NA. The weight_mg measurements for these data entries will still be reflected in the original data. In a later stage, this dataframe will be combined with the original dataframe, and the eventIDs will be given a unique string. 

bongo_occ1 <- rbind(bongo_pre_wrangle, bongo_number_length)
bongo_occ1$number <- as.numeric(bongo_occ1$number)
bongo_occ1 <- bongo_occ1[order(bongo_occ1$number, decreasing = TRUE), ]
bongo_occ1 <- bongo_occ1[order(as.character(bongo_occ1$sample_id)), ]
bongo_occ1$sample_id <- sub('[.]', '_', make.names(bongo_occ1$sample_id, unique=TRUE))
# For some reason this adds an X for sample_id 22020 and 22021 so this needs to get removed: 
bongo_occ1$sample_id <- gsub("X", "", bongo_occ1$sample_id)

# Now we have both the original data entry and duplicated rows in a dataframe. The only things that needs to be changed in the dataframe is the length measurements within the duplicated rows, to reflect the individual measurements. I am unsure if there is a faster way to do this, but a cumbersome way is: 

bongo_occ1 <- bongo_occ1 %>% 
  rename(eventID = sample,
         scientificName = species) %>%
  mutate(length_mm = case_when(
    sample_id == "22020_1" ~ 20,
    sample_id == "22020_2" ~ 19,
    sample_id == "22020_3" ~ 15,
    sample_id == "22021_1" ~ 10,
    sample_id == "22021_2" ~ 16,
    sample_id == "22021_3" ~ 16,
    sample_id == "SS119_1" ~ 11,
    sample_id == "SS119_2" ~ 12,
    sample_id == "SS119_3" ~ 14,
    sample_id == "SS119_4" ~ 15,
    sample_id == "SS12_1" ~ 12,
    sample_id == "SS12_2" ~ 13,
    sample_id == "SS126_1" ~ 15,
    sample_id == "SS126_2" ~ 12,
    sample_id == "SS176_1" ~ 37,
    sample_id == "SS176_2" ~ 41,
    sample_id == "SS176_3" ~ 34,
    sample_id == "SS176_4" ~ 42,
    sample_id == "SS185_1" ~ 15,
    sample_id == "SS185_2" ~ 22,
    sample_id == "SS38_1" ~ 14,
    sample_id == "SS38_2" ~ 23,
    sample_id == "SS42B_1" ~ 17,
    sample_id == "SS42B_2" ~ 25,
    sample_id == "SS55_1" ~ 30,
    sample_id == "SS55_2" ~ 21,
    sample_id == "SS55_3" ~ 22,
    sample_id == "SS55_4" ~ 24,
    sample_id == "SS57_1" ~ 13,
    sample_id == "SS57_2" ~ 13,
    sample_id == "SS57_3" ~ 14,
    sample_id == "SS57_4" ~ 14,
    sample_id == "SS58_1" ~ 17,
    sample_id == "SS58_2" ~ 18,
    sample_id == "SS58_3" ~ 21,
    sample_id == "SS59_1" ~ 12,
    sample_id == "SS59_2" ~ 12,
    sample_id == "SS59_3" ~ 13, 
    sample_id == "SS59_4" ~ 14,
    sample_id == "SS59_5" ~ 14,
    sample_id == "SS59_6" ~ 14,
    sample_id == "SS68_1" ~ 15,
    sample_id == "SS68_2" ~ 16,
    sample_id == "SS68_3" ~ 17,
    sample_id == "SS69_1" ~ 12,
    sample_id == "SS69_2" ~ 13,
    sample_id == "SS69_3" ~ 14, 
    sample_id == "SS69_4" ~ 17,
    sample_id == "Z318_1" ~ 35,
    sample_id == "Z318_2" ~ 40,
    sample_id == "SS81_1" ~ 29,
    sample_id == "SS81_2" ~ 14,
    sample_id == "SS81_3" ~ 15,
    sample_id == "SS81_4" ~ 16,
    sample_id == "SS81_5" ~ 17, 
    sample_id == "SS81_6" ~ 18,
    sample_id == "SS81_7" ~ 12,
    sample_id == "SS81_8" ~ 13
  )) %>%
  mutate(species = case_when(
    sample_id == "SS81_1" ~ "sagitta",
    sample_id == "SS81_2" ~ "E pacifica",
    sample_id == "SS81_3" ~ "E pacifica",
    sample_id == "SS81_4" ~ "E pacifica",
    sample_id == "SS81_5" ~ "E pacifica", 
    sample_id == "SS81_6" ~ "E pacifica",
    sample_id == "SS81_7" ~ "T spinifera",
    sample_id == "SS81_8" ~ "T spinifera"
  )) %>%
 # filter only for the entries where number = 1 
 filter(number == 1) %>%
  mutate(occurrenceStatus = ifelse(number > 0, "present", "absent"),
         occurrenceID = " ") 
```

Additionally, we want to create a preliminary occurrence table for species that have number > 1, can be distinguished on species or genus level but have no distinct or ranged length measurements, or only a single length measurement. 

``` {r bongo_occ2, eval = FALSE}
bongo_occ2 <- bongo_number
bongo_occ2 <- bongo_occ2 %>% filter(bongo_occ2, !(sample_id %in% c("Petri dish", "SS12", "SS14", "SS13", "SS27", "SS38", 
                                                    "SS43", "SS44", "SS45", "SS42B", "SS176", "22020", "22021",
                                                    "SS59", "SS58", "SS57", "SS55", "Z318", "SS68", "SS69", "SS78",
                                                    "SS79", "SS77", "SS81", "SS119", "SS126", "SL10", "SS138", 
                                                    "SS173", "SS171", "22027", "SS70", "SS122", "SS139", "SS164",
                                                    "SS185", "SS82"))) %>%
  mutate(occurrenceID = " ",
         occurrenceStatus = "present") %>%
  rename(eventID = sample,
         scientificName = species)
```

The next chunk of code is for the data entries where number > 1, _but_ no distinct measurement lengths are provided. In the code above, these entries were _not_ given an occurrenceID (but the individual measurements were); however, here we do provide an occurrenceID for these entries, and in the eMoF table they will have measurementTypes `minimum length` and `maximum length` to display the range

``` {r occ_range, eval = FALSE}
# From the original dataset, filter out all the numbers in the `number` column that contain a range (i.e., a -). 
bongo_occ3 <- bongo %>% 
  dplyr::filter(grepl("-", bongo$length_mm)) %>%
  mutate(occurrenceID = " ",
         occurrenceStatus = "present") %>%
  rename(eventID = sample, 
         scientificName = species)
```

For the data entries where number is not precise, nor a range, i.e., >3, >4, ~3 and >1, these will not get an `occurrenceID` or `occurrenceStatus`, but the measurements will be linked directly to their `eventID`. Third, we also add an `occurrenceID` and `occurrenceStatus` to all the data entries where number = 1. 

``` {r occ_number1, eval = FALSE}
bongo_occ4 <- bongo %>% filter(number == 1) %>%
  mutate(occurrenceID = " ",
         occurrenceStatus = "present") %>%
  rename(eventID = sample,
         scientificName = species)
```

To create the final occurrence table, the 

``` {r combined_occ, eval = FALSE}
# Next, combine bongo_occ_wr with the original dataframe (bongo)
bongo_occ_fnl <- rbind(bongo_occ1, bongo_occ2, bongo_occ3, bongo_occ4) %>%
  select(eventID, occurrenceID, occurrenceStatus, scientificName)
```

For sample_id `Petri dish` there are four data entries, all for the same species, so in our current set up these all have the same `sample_id` (GoA2019_Stn11:cast1:bongo:Net1:Petri dish). We will deal with these entries separate. 

Where length (mm) is e.g. 15 - 17mm, should we filter these samples from the rest and include a minimum length and maximum length column in the eMoF table?

To do: For species where number > 1, but only one length measurement is given, should we assume that all the individuals have the same length measurement? _Or, alternatively, perhaps we should make `number` a variable measured, and therefore record it in the extended measurementOrFact table_?

For some reason each measurement does not have their own associated `eventID`. Where number = 7, the notes indicate that this data entry regards 8 individuals, which have been identified to species or genus: n = 1 sagitta spp., n = 5 E. pacifica and n = 2 T. spinifera. Therefore, this eventID is split into 8 unique eventIDs to capture each unique length measurement. Unfortunately, no unique weight measurements were recorded. However, as length measurements have been associated to a species or genus, we want to make sure to include these in the Occurrence Core. 

What we want to do in the following chunk of code, is for each unique data entry where number > 1, we make a duplicate number of rows of that specific sample. The number of duplicate rows is equal to `number` + 1 (the +1 is because we want to preserve the original entry also)

Brian's comments regarding the size fractions: _Samples were size fractions. IN some cases the 2mm and 4mm size fractions have been split out to obtain measurements f species. The sum of these measurements is the total size fraction biomass._

All species that are listed as `size fraction` belong to the group "Zooplankton". How can we best represent this group according to OBIS / WoRMS standards?

After a brief discussion with Julian, it was agreed on that entries where Species = `Size fraction`, will not have an Occurrence Core associated to it, because it is not possible to associate a URN from WoRMS to this class or group (`Zooplankton`). The same goes for entries where no common rank can be associated, such as `Jellyfish, radiolarian, chaetognath` and `Gelatinous`. For other entries where no clear classification is provided, e.g. `crab zoea` and `jelly mass`, the lowest common rank URN is listed. 

Where do we draw the line when it comes to associating an Occurrence(ID) to an entry? Would this only be for species that have been identified to Species or Genus level, as perhaps a classification on phylum or kingdom level does not really provide any information?

``` {r bongo_occ}
bongo_occ <- bongo %>%
  subset(species != "Size fraction" & species != "Jellyfish, radiolarian, chaetognath" & species != "Gelatinous") %>%
  mutate(occurrenceStatus = ifelse(number > 0, "present", "absent")) %>% 
  rename(eventID = sample,
         scientificName = species) %>%
  mutate(occurrenceID = paste("IYS_GoA2019_occ", row_number(),sep = ""),
         # I am not happy yet with this occurrenceID but gives an indication. 
    scientificNameID = case_when(
      scientificName == "Thysanoessa spinifera" ~ "urn:lsid:marinespecies.org:taxname:237874", 
      scientificName == "Sergestes similis" ~ "urn:lsid:marinespecies.org:taxname:514127",
      # Accepted name is Eusergestes similis
      scientificName == "Euphausia pacifica" ~ "urn:lsid:marinespecies.org:taxname:237851",
      scientificName == "Salpa aspera" ~ "urn:lsid:marinespecies.org:taxname:137270",
      scientificName == "Copepod" ~ "urn:lsid:marinespecies.org:taxname:1080",
      # Subclass: Copepoda
      scientificName == "Neocalanus cristatus" ~ "urn:lsid:marinespecies.org:taxname:104470" ,
      scientificName == "Cyphocaris" ~ "urn:lsid:marinespecies.org:taxname:101603",
      scientificName == "Squat lobster" ~ "urn:lsid:marinespecies.org:taxname:106671",
      # Unsure whether the squat lobster is part of the superfamily Chirostyloidea or Galatheoidea, so the lowest common rank (InfraOrder) of Anomura was chosen. 
      scientificName == "Siphonophore" ~ "urn:lsid:marinespecies.org:taxname:1371",
      scientificName == "Chaetognath (Sagitta)" ~ "urn:lsid:marinespecies.org:taxname:5949",
      # Chaetognatha - class: Sagittoidea
      scientificName == "Beroe sp." ~ "urn:lsid:marinespecies.org:taxname:1434803",
      scientificName == "Euphausiid" ~ "urn:lsid:marinespecies.org:taxname:110671",
      # Family: Euphasiidae
      scientificName == "Chaetognath & Ctenophore" ~ "urn:lsid:marinespecies.org:taxname:2",
      # Rank: Kingdom is the lowest common rank of phylum 'chaetognatha and 'ctenophora'
      scientificName == "Siphonophore (Lensia type)" ~ "urn:lsid:marinespecies.org:taxname:135365",
      scientificName == "Aequorea sp." ~ "urn:lsid:marinespecies.org:taxname:116998",
      scientificName == "Jelly mass" ~ "urn:lsid:marinespecies.org:taxname:1267",
      # URN for 'Jelly mass' is that for phylum: Cnidaria
      scientificName == "Radiolarians" ~ "urn:lsid:marinespecies.org:taxname:582421",
      # Phylum: Radiozoa
      scientificName == "Paraphronima (gracilis)" ~ "urn:lsid:marinespecies.org:taxname:236597",
      scientificName == "Crab zoea" ~ "urn:lsid:marinespecies.org:taxname:1065",
      # URN for 'crab zoea' is that for phylum: Arthropoda. 
      scientificName == "Microstomus pacificus" ~ "urn:lsid:marinespecies.org:taxname:274294",
      scientificName == "Thysanoessa (longipes)" ~ "urn:lsid:marinespecies.org:taxname:237873",
      scientificName == "Myctophid larva" ~ "urn:lsid:marinespecies.org:taxname:125498",
      # Family: Myctophidae
      scientificName == "Primno pacifica" ~ "urn:lsid:marinespecies.org:taxname:286539",
      # Genus: Primnoa
      scientificName == "Japatella diaphana" ~ "urn:lsid:marinespecies.org:taxname:138849",
      # Genus: Japetella
      scientificName == "Clio pyrimidata" ~ "urn:lsid:marinespecies.org:taxname:139033",
      # Species: Clio pyramidata
      scientificName == "Paraeuchaeta sp." ~ "urn:lsid:marinespecies.org:taxname:196874",
      scientificName == "Thysanoessa sp." ~ "urn:lsid:marinespecies.org:taxname:110679",
      scientificName == "Gastropod veliger" ~ "urn:lsid:marinespecies.org:taxname:101",
      # Class: Gastropoda - veliger are the planktonic larvae
      scientificName == "Tarletonbeania crenularis" ~ "urn:lsid:marinespecies.org:taxname:282927",
      scientificName == "Limacina helicina" ~ "urn:lsid:marinespecies.org:taxname:140223",
      scientificName == "Phronima (sedentaria)" ~ "urn:lsid:marinespecies.org:taxname:103272",
      scientificName == "Hydromedusae" ~ "urn:lsid:marinespecies.org:taxname:1337",
      # Hydromedusae belong to the Hydrozoa as a sub-class, along with the Scyphomedusae. In WoRMS, the closest accepted URN I could find is that for subclass "Hydroidolina". As I'm not sure if this is the correct one, currently the URN for Hydromedusae reflects the URN for Hydrozoa. 
      scientificName == "Siphonophore" ~ "urn:lsid:marinespecies.org:taxname:1371",
      scientificName == "siphonophore" ~ "urn:lsid:marinespecies.org:taxname:1371",
      # Order: Siphonophorae
      scientificName == "Ctenophore / jellyfish" ~ "urn:lsid:marinespecies.org:taxname:1248",
      # As they are listed under the group 'Ctenophore', the associated URN above links to this phylum.
      scientificName == "sagitta" ~ " ", 
      scientificName == "E pacifica" ~ " ",
      scientificName == "T spinifera" ~ " "
    )
  ) %>%
  rename(Preparations = preservation) %>%
  select(eventID, occurrenceID, scientificName, scientificNameID, occurrenceStatus, Preparations) %>%
  mutate(basisOfRecord = "HumanObservation")

# Make sure the folder path exists already (e.g. ./Bongo/tidy_data)
write_csv(bongo_occ, here("Bongo", "tidy_data", "bongo_event.csv"))
drive_upload(here("Bongo", "tidy_data", "bongo_event.csv"),
             path = " ",
             name = "bongo_event.csv",
             overwrite = TRUE)
```

## extended measurementOrFact

``` {r seafloor, eval = FALSE}
bongo_botdepth <- bongo %>% 
  select(eventID = cast, depth) %>%
  distinct(eventID, .keep_all = TRUE) %>%
  pivot_longer(cols = depth,
               names_to = "measurementType",
               values_to = "measurementValue") %>%
  mutate(measurementValue = as.character(measurementValue),
         measurementID = paste(eventID, "depth", sep = ":"),
         measurementType = recode(measurementType,
                                  depth = "seafloor depth"),
         measurementTypeID = "http://vocab.nerc.ac.uk/collection/C00/current/SCILOG/",
         measurementUnit = "m",
         measurementUnitID = "http://vocab.nerc.ac.uk/collection/P06/current/ULAA/" ) %>%
  select(measurementID, eventID, measurementType, measurementTypeID, measurementValue,
         measurementUnit, measurementUnitID)
```

Though an occurrenceID was not created for each data entry, measurements can be linked either directly to the `eventID` or through the `occurrenceID`. The following measurements are linked to either the `eventID` or `occurrenceID`: `size fraction`, `length_mm`, `length_type`, and `weight_mg`. Additional information that might in the future be included as well could be `Stage`, which reflects a lifeStage of an organism. However, because the datasheet includes a wide variety of organisms, all with different 'levels' of a lifeStage, to what extent is it necessary to choose a uniform 'coding' system for this variable?

When the species or genus has been identified, the measurements are associated to the occurrenceID. The reason for this is that URNs from [WoRMS](http://www.marinespecies.org/) can be associated to the species entries. For the entries where the `Species` are more descriptive or which haven't been able to get associated to a URN from WoRMS, the measurements are linked directly to the `eventID`. This concerns the following listed "Species": `Gelatinous`, `Jellyfish, radiolarian, chaetognath`, and `size fraction`. 

So a total of two extended measurementOrFact cores will be created; one linking to the `occurrenceIDs` and the other directly to the `eventID`. We first create the eMoF table that links directly to the `eventID`:  

``` {r eMoF, eval = FALSE}
bongo_emof <- bongo %>% filter(species %in% c("Size fraction", 
                                              "Jellyfish, radiolarian, chaetognath", "Gelatinous")) %>%
  select(eventID = sample, 
         number, size_fraction, 
         length = length_mm,
         weight = weight_mg,
         length_type)

```

When examining this dataset, we can identify three entries that we need to explore further, where number != 0. k
%>%
  mutate_all(as.character) %>%
  pivot_longer(cols = number:length_type, 
               names_to = "measurementType",
               values_to = "measurementValue") %>%
  mutate(
    measurementID = case_when(
      measurementType == "number" ~ paste(eventID, "number", sep = ":"),
      measurementType == "size_fraction" ~ paste(eventID, "size_fraction", sep = ":"),
      measurementType == "length" ~ paste(eventID, "length", sep = ":"),
      measurementType == "length_type" ~ paste(eventID, "length_type", sep = ":"),
      measurementType == "weight" ~ paste(eventID, "weight", sep = ":")
    ),
    measurementTypeID = case_when(
      measurementType == "number" ~ " ",
      measurementType == "size_fraction" ~ " ",
      measurementType == "sample_type" ~ " ",
      # samplingProtocol
      measurementType == "length" ~ "http://vocab.nerc.ac.uk/collection/S06/current/S0600015/"
      # I want to check if maybe there is a better Controlled Vocab for body size
      measurementType == "length_type" ~ " ",
      measurementType == "weight" ~ "	http://vocab.nerc.ac.uk/collection/S06/current/S0600088/",
      measurementType == "tissue" ~ " ",
      measurementType == "stage" ~ " "
    ), 
    measurementUnit = case_when(
      measurementType == "length" ~ "mm",
      measurementType == "weight" ~ "g",
      measurementType == "size_fraction" ~ "" 
      # If this is equal to mesh size
    ), 
    measurementUnitID = case_when(
      measurementUnit == "mm" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UXMM/",
      measurementUnit == "g" ~ "	http://vocab.nerc.ac.uk/collection/P06/current/UGRM/"
      measurementUnit == " "
      # Reminder: there is no NERC Controlled Vocabulary for mg, so values are formatted to 'grams'. 
      # Is size fraction equal to mesh size?
    )
    )
    )
    
    
  ))

```

```

## MeasurementOrFact

The following variables are connected to an occurrenceID in the measurementOrFact (eMoF) table: 
- size fraction
- Length (mm)
- Length type?
- Weight (mg)
# As there is no Controlled Vocabulary for mg, these values are transformed to 'grams'. 


- Stage (= lifeStage? is all NA)
- Sample type
# Perhaps sample type should be included in the Event Core under samplingProtocol? It's not a measurement but more method of analysis. 

Add a section about comments/notes associated to the measurements. 




Next step is creating the extended measurementOrFact (eMoF) table. From personal communication with the data provider (Brian Hunt) _in some cases the 2mm and 4mm size fractions have been split out to obtain measurements of species. The sum of these measurements is the total size fraction biomass_. Therefore we first have to filter out the measurements that have been split out, and sum these fractions. 

Brian indicated that this was only done for some cases in the 2mm and 4mm size fractions, so the first step is to filter out all entries where the weight has not been determined (TBD), make the weight_mg as numeric, and examine all entries where size_fraction = 2 or 4:

``` {r biomass_wrangling, eval = FALSE}
bongo_biomass <- bongo[!(bongo$weight_mg == "TBD"),]
bongo_biomass$weight_mg <- as.numeric(as.character(bongo_biomass$weight_mg))
bongo_biomass <- bongo_biomass %>% filter(size_fraction %in% c(2, 4))
```

``` {r eMoF, eval = FALSE}
bongo_measurement <- bongo %>%
  select(number, size_fraction, sample_type,
         length = length_mm,
         length_type, 
         weight = weight_mg,
         tissue, stage) %>%
  

The sample comments needed to be tidied separately (not part of the above pipe sequence) because they belong in the measurementRemarks column. I need to recreate measurementID so that the two data frames can be joined.

``` {r measurementRemarks, eval = FALSE}
bongo_measurementRemarks <- bongo %>%
  select(eventID = sample, notes) %>%
  pivot_longer(cols = notes, values_to = "measurementRemarks") %>%
  mutate(measurementID = case_when(
    name == "notes" ~ paste(eventID, "notes", sep = ":"))) %>%
  select(measurementID, measurementRemarks)

bongo_measurementOrFact <-
  bind_rows(bongo_botdepth, bongo_measurement) %>%
  left_join(bongo_measurementRemarks) %>%
  select(
    measurementID,
    eventID,
    measurementType,
    measurementTypeID,
    measurementValue,
    measurementUnit,
    measurementUnitID,
    measurementRemarks
```



