---
title: "2019 IYS - Bongo Data wrangle"
author: "Tim van der Stap"
date: "6/17/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lubridate)
library(janitor)
library(readxl)
library(here)
library(parsedate)
library(googledrive)
library(uuid)
```

The raw data is stored on GoogleDrive. The first step is to download the file from Google Drive to a local folder on your computer's hard drive. 

``` {r file_download, eval = FALSE}
# Make sure your folder path exists already (e.g. ./Bongo/raw_data)
drive_download("https://docs.google.com/spreadsheets/d/1vvIwlsIkuc9vHtVrv2l3pXeyoWpEX_gw/edit#gid=287253584", 
               path = here::here("Bongo", "raw_data", 
                                 "Zoop Bongo Isotopes_IYS_Dry Weight_Mar31.xlsx"),
               overwrite = TRUE)
```

Read in the dataset from your local drive:

``` {r data wrangle, eval = FALSE}
bongo <- read_excel(here("Bongo", "raw_data", 
                       "Zoop Bongo Isotopes_IYS_Dry Weight_Mar31.xlsx"), 
                  sheet = "Samples collected") %>%
  janitor::clean_names() %>%
  # Convert the standalone time value (UTC+12) into ISO8601 extended format
  mutate(Date = lubridate::dmy(date),
         Time = format(start_time, format = "%H:%M:%S"),
         dateTime = format_iso_8601(as.POSIXct(paste(Date, Time), 
                                               format="%Y-%m-%d %H:%M:%S", 
                                               tz="Asia/Kamchatka")),
         dateTime = str_replace(dateTime, "\\+00:00", "Z"),
         cruise = "GoA2019",
         station = paste(cruise, station, sep="_Stn"),
         cast = paste(station, "cast1", sep=":"),
         ndepth = paste(cast, net, sep = ":bongo:Net"),
         sample = paste(ndepth, sample_id, sep=":")
  )
```

Dataframes are created for each unique `eventID` layer, with unique associated columns. Eventually, the data frames get joined, and the event table gets saved locally and in Google Drive. The column `eventRemarks` is not a required column, and currently only contains descriptive information. However, it is a good method to understand the structure in the dataset. A visual diagram of the structure of the dataset is provided [here](https://app.diagrams.net/#G1CCBTro5std-UGbHdy6mVMa3QpZipGvIP). 


``` {r bongo_event, eval = FALSE}
bongo_cruise <- bongo %>% 
  select(eventID = cruise) %>%
  distinct(eventID) %>%
  mutate(eventRemarks = "cruise")

bongo_station <- bongo %>%
  select(eventID = station,
         parentEventID = cruise) %>% 
  distinct(eventID, .keep_all = TRUE) %>% 
  mutate(eventRemarks = "station")

# Join date and coordinates to cast
bongo_cast <- bongo %>%
  select(eventID = cast,
         parentEventID = station,
         eventDate = dateTime,
         decimalLatitude = start_latitude,
         decimalLongitude = start_longitude) %>%
  distinct(eventID, .keep_all = TRUE) %>%
  mutate(eventRemarks = "cast")

bongo_ndepth <- bongo %>% 
  select(eventID = ndepth,
         parentEventID = cast,
         minimumDepthInMetres = sample_depth,
         maximumDepthInMetres = sample_depth) %>% 
  distinct(eventID, .keep_all = TRUE) %>% 
  mutate(eventRemarks = "sample")

bongo_sample <- bongo %>%
  select(eventID = sample,
         parentEventID = ndepth) %>%
  distinct(eventID, .keep_all = TRUE) %>%
  mutate(eventRemarks = "subsample")

bongo_event <- bind_rows(bongo_cruise,bongo_station,bongo_cast,bongo_ndepth,bongo_sample) %>% 
  select(eventID, parentEventID:maximumDepthInMetres, eventRemarks) %>%
 mutate(type = "HumanObservation")

# Make sure the folder path exists already (e.g. ./Bongo/tidy_data)
write_csv(bongo_event, here("Bongo", "tidy_data", "bongo_event.csv"))
drive_upload(here("Bongo", "tidy_data", "bongo_event.csv"),
             path = " ",
             name = "bongo_event.csv",
             overwrite = TRUE)
```

## Occurrence Core

An `occurrenceID` and `occurrenceStatus` can only be provided to data entries where species have been identified to a species or genus level. Only for these species can a URN be associated from WoRMS. So first we inspect all the unique input for the `species` column, and filter for all these species: 

Q: Where do we draw the line when it comes to associating an Occurrence(ID) to an entry? Would this only be for species that have been identified to Species or Genus level, as perhaps a classification on phylum or kingdom level does not really provide any information?

``` {r bongo_occ_pre_wrangle, eval = FALSE}
unique(bongo$species)

# Identify all entries that have not been identified to species or genus level: 
bongo_occ_spp <- bongo %>% filter(!(species%in% c("Size fraction", "Chaetognath & Ctenophore", "Jelly mass",
                                              "Crab zoea", "Jellyfish, radiolarian, chaetognath", "Gelatinous",
                                              "Ctenophore / jellyfish")))
```

Upon inspection of the data filtered out, there are two sample_ids for which the species = Zooplankton, but in the notes unique species have been identified _and_ their length measured. For these two sample_ids we can another occurrence table. sample_id SS81 requires special attention because number = 7, but the notes distinguish 8 unique measurements. Additionally, sample_id SS133 requires special attention because although number = 1, in the notes it says that jellies were observed (length range: 10 - 15mm) and 3 sagitta spp. were observed, with individual lengths measured. 

We will split up the data entries for these two sample_id's accordingly, and merge it back with the dataset `bongo_occ_spp`. 

``` {r occurrence table 5, eval = FALSE}
bongo_5 <- bongo %>% filter(sample_id %in% c("SS81", "SS133"))

# Upon inspection, for SS81 there are 8 unique measurements (though number = 7), and for SS133 there are 4 unique length measurements (3 distinct measurements and 1 ranged measurement). Therefore, we change the value in the number column accordingly: 
bongo_5$number[1] <- 8
bongo_5$number[2] <- 4
bongo_5_new <- data.frame(bongo_5[rep(seq_len(dim(bongo_5)[1]),
                                  bongo_5$number), , drop = FALSE], row.names = NULL) %>%
  mutate(number = 1,
         weight_mg = NA)

bongo_occ5 <- rbind(bongo_5, bongo_5_new)
bongo_occ5$number <- as.numeric(bongo_occ5$number)
bongo_occ5 <- bongo_occ5[order(bongo_occ5$number, decreasing = TRUE), ]
bongo_occ5 <- bongo_occ5[order(as.character(bongo_occ5$sample_id)), ]
bongo_occ5$sample_id <- sub('[.]', '_', make.names(bongo_occ5$sample_id, unique=TRUE))
bongo_occ5 <- bongo_occ5 %>%
  mutate(species = case_when(
    sample_id == "SS133" ~ "Size fraction",
    sample_id == "SS133_1" ~ "Sagitta",
    sample_id == "SS133_2" ~ "Sagitta",
    sample_id == "SS133_3" ~ "Sagitta",
    sample_id == "SS133_4" ~ "jellies",
    sample_id == "SS81_1" ~ "Sagitta",
    sample_id == "SS81" ~ "Size fraction",
    sample_id == "SS81_2" ~ "E pacifica",
    sample_id == "SS81_3" ~ "E pacifica",
    sample_id == "SS81_4" ~ "E pacifica",
    sample_id == "SS81_5" ~ "E pacifica", 
    sample_id == "SS81_6" ~ "E pacifica",
    sample_id == "SS81_7" ~ "T spinifera",
    sample_id == "SS81_8" ~ "T spinifera"))
bongo_occ5 <- bongo_occ5 %>% 
  mutate(number = case_when(
    sample_id == "SS133_1" ~ 1,
    sample_id == "SS133_2" ~ 1,
    sample_id == "SS133_3" ~ 1,
    sample_id == "SS133_4" ~ 2,
    sample_id == "SS81_1" ~ 1,
    sample_id == "SS81_2" ~ 1,
    sample_id == "SS81_3" ~ 1,
    sample_id == "SS81_4" ~ 1,
    sample_id == "SS81_5" ~ 1,
    sample_id == "SS81_6" ~ 1,
    sample_id == "SS81_7" ~ 1,
    sample_id == "SS81_8" ~ 1))
bongo_occ5 <- bongo_occ5 %>%
  mutate(length_mm = case_when(
    sample_id == "SS133_1" ~ 44,
    sample_id == "SS133_2" ~ 45,
    sample_id == "SS133_3" ~ 48,
    sample_id == "SS133_4" ~ 0, # Find a way to add range 10 - 15mm here.
    sample_id == "SS81_1" ~ 29,
    sample_id == "SS81_2" ~ 14,
    sample_id == "SS81_3" ~ 15,
    sample_id == "SS81_4" ~ 16,
    sample_id == "SS81_5" ~ 17,
    sample_id == "SS81_6" ~ 18,
    sample_id == "SS81_7" ~ 12,
    sample_id == "SS81_8" ~ 13))  
bongo_occ5$length_mm[5] <- "10-15mm"

# Add bongo_occ5 to the dataframe where we filtered out the all entries that have not been identified to species or genus level: 
bongo_occ_spp <- rbind(bongo_occ_spp, bongo_occ5)
```

The measurements of weight, length, life stage and taxonomic group will still be included, however they will linked directly to the `eventID` rather than the `occurrenceID`. In other words, _no_ Occurrence Core will be created for these data entries!

When examining the remaining data entries in the bongo_occ dataset, we can identify some problems, especially in the column `number`. This column indicates the count of a species observed in each trawl, and `count` and `number` will be used synonymously throughout this script. Some problems that we encountered are the following: 

1) Some data entries have counts that are not a specific number (i.e., >3, >4, ~3 and >1);
2) Some data entries that have a count > 1, appear to be aggregated entries, as only a single length measurement is associated. However, sometimes individual measurements or classifications are provided in the `notes` column. As we don't want to mess with the raw data .csv file, we have to manually inspect these entries to ensure that no (individual) measurements get overlooked;
3) Some data entries have a count > 1, and an associated range in the length measurement (i.e., 15 - 17mm);
4) Some data entries do not have a species or genus specified in the `species` column, but only a very broad classification as 'Zooplankton'.

_To address these issues, four different occurrence tables will be created, that eventually get merged to a single Occurrence Core! In all these occurrence tables, species have been identified to species or genus level._

bongo_occ1. Occurrence table for entries with no distinct number recorded (i.e., >4, >3 or >1);
bongo_occ2. Occurrence table for entries where count > 1, but individual measurements (length) are provided in the notes. For these entries, unique `occurrenceID`s will be created;
bongo_occ3. Occurrence table for entries where count > 1, and a range of length measurements is provided in the `length_mm` column; 
bongo_occ4. Occurrence table for individual data entries (i.e., where `number` = 1).

These four occurrence tables will eventually be concatenated into a single Occurrence Core. 

Let's first examine the data entries where the counts do not have a specific number associated to it. As the species has been identified to a species or genus-level, we do want to assign an `occurrenceID` and `occurrenceStatus` to them. An `occurrenceID` will be associated at a later stage when all the created occurrence tables are joined. 

``` {r bongo_occ_1, eval = FALSE} 
unique(bongo_occ_spp$number)

# This identifies that there are three entries where the number (or count) is not specified: ">1", ">3" and ">4".
bongo_occ1 <- bongo_occ_spp %>% filter(number == ">3" | number == ">4" | number == ">1") %>%
  mutate(occurrenceID = " ",
         occurrenceStatus = "present") %>%
  rename(eventID = sample,
         scientificName = species)
```

Next, we create an occurrence table to address the second issue we are facing, that _some data entries have a count >1, i.e., appear to be aggregated entries_. For some of these data entries, individual measurements or classifications are provided in the `notes` column. Therefore, we need to manually inspect the data entries where count >1. If individual measurements are provided, we want split the data entry, and associate a unique `occurrenceID` and `occurrenceStatus`, _not_ `eventID`(!), to those newly created `occurrenceID`s. Eventually this newly created dataframe with the duplicated rows will be combined with the "original" dataframe. 

We create a separate table for the unique sample_id's that have number > 1 and where the number matches the individual length measurements in `length_mm`. Our intention here to _add_ duplicate rows for each unique sample_id equal to the value under `number` associated to that data entry. However, we want to keep the original data entry row (the `eventID`) intact. In other words, if the `eventID` indicates e.g. four individual length measurements in the `length_mm` column, we want to make sure these all get a unique `occurrenceID`. 

``` {r bongo_occ_2, eval = FALSE}
bongo_new <- bongo_occ_spp %>% filter(number > 1)

# Upon manual inspection, there are several data entries where count > 1, and the individual length measurements are provided in the notes. We filter for all the sample_ids where individual length measurements are recorded in the notes. Upon inspection, for sample_id `Petri dish` there is one entry where number = 3, but no individual measurements are provided. Therefore this data entry is removed from this newly created dataframe: 

bongo_occ_2 <- bongo_new %>% filter(sample_id %in% c("SS12", "SS38", "SS42B", "22020", "22021",
                                               "SS59", "SS58", "SS57", "SS55", "Z318", "SS68", "SS69",
                                               "SS119", "SS126", "SS176", "SS185"))
```

Upon examination of this dataset (bongo_occ_2) we notice that there are four data entries (rows) with a similar sample_id ("Petri dish"), but unique associated length measurements. So our first step here is to filter out this sample_id and assign a unique `eventID`. However, upon inspection, one of these data entries does not have unique length measurements associated to it, so we remove this data entry. 


For sample_id `Petri dish` there are four data entries, all for the same species, so in our current set up these all have the same `sample_id` (GoA2019_Stn11:cast1:bongo:Net1:Petri dish). We will deal with these entries separate. 

``` {r xxx, eval = FALSE}
bongo_petri <- bongo_new %>% filter(sample_id == "Petri dish")
bongo_petri <- bongo_petri[-4, ] %>%
  mutate(sample_id = paste(sample_id, row_number(), sep = "_"))

# Merge this dataframe back in with the bongo_occ_2: 
bongo_occ_new <- rbind(bongo_occ_2, bongo_petri)
```

The next step is to create duplicate rows of these data entries, equal to the count in the `number` column. These duplicated rows will need to reflect the individual length (mm) measurements and also reflect that it now represents just a single measurement (i.e., number = 1).

``` {r xxx, eval = FALSE}
bongo_occ_2dup <- data.frame(bongo_occ_new[rep(seq_len(dim(bongo_occ_new)[1]),
                                                       bongo_occ_new$number), ,
                                    drop = FALSE], row.names = NULL) %>%
  mutate(number = 1)

#  Additionally, for all the split unique data entries in this dataframe, the weight_mg measurement has to be NA. The weight_mg measurements for these data entries will still be reflected in the original data. In a later stage, this dataframe will be combined with the original dataframe, and the occurrenceIDs will be given a unique string. 

bongo_occ_2dup$weight_mg <- ifelse(bongo_occ_2dup$weight_mg == "TBD", "TBD", NA)

bongo_occ2 <- rbind(bongo_occ_new, bongo_occ_2dup)
bongo_occ2$number <- as.numeric(bongo_occ2$number)
bongo_occ2 <- bongo_occ2[order(bongo_occ2$number, decreasing = TRUE), ]
bongo_occ2 <- bongo_occ2[order(as.character(bongo_occ2$sample_id)), ]
bongo_occ2$sample_id <- sub('[.]', '_', make.names(bongo_occ2$sample_id, unique=TRUE))
# For some reason this adds an X for sample_id 22020 and 22021 so this needs to get removed: 
bongo_occ2$sample_id <- gsub("X", "", bongo_occ2$sample_id)

# Now we have both the original data entry and duplicated rows in a dataframe. The only things that needs to be changed in the dataframe is the length measurements within the duplicated rows, to reflect the individual measurements. I am unsure if there is a faster way to do this, but a cumbersome way is: 

bongo_occ2 <- bongo_occ2 %>% 
 mutate(length_mm = case_when(
    sample_id == "Petri_dish_1.1" ~ 70,
    sample_id == "Petri_dish_1.2" ~ 65,
    sample_id == "Petri_dish_1.3" ~ 55,
    sample_id == "Petri_dish_2.1" ~ 60,
    sample_id == "Petri_dish_2.2" ~ 60,
    sample_id == "Petri_dish_2.3" ~ 55,
    sample_id == "Petri_dish_3.1" ~ 55,
    sample_id == "Petri_dish_3.2" ~ 50,
    sample_id == "Petri_dish_3.3" ~ 50,
    sample_id == "Petri_dish_3.4" ~ 45,
    sample_id == "22020_1" ~ 20,
    sample_id == "22020_2" ~ 19,
    sample_id == "22020_3" ~ 15,
    sample_id == "22021_1" ~ 10,
    sample_id == "22021_2" ~ 16,
    sample_id == "22021_3" ~ 16,
    sample_id == "SS119_1" ~ 11,
    sample_id == "SS119_2" ~ 12,
    sample_id == "SS119_3" ~ 14,
    sample_id == "SS119_4" ~ 15,
    sample_id == "SS12_1" ~ 12,
    sample_id == "SS12_2" ~ 13,
    sample_id == "SS126_1" ~ 15,
    sample_id == "SS126_2" ~ 12,
    sample_id == "SS176_1" ~ 37,
    sample_id == "SS176_2" ~ 41,
    sample_id == "SS176_3" ~ 34,
    sample_id == "SS176_4" ~ 42,
    sample_id == "SS185_1" ~ 15,
    sample_id == "SS185_2" ~ 22,
    sample_id == "SS38_1" ~ 14,
    sample_id == "SS38_2" ~ 23,
    sample_id == "SS42B_1" ~ 17,
    sample_id == "SS42B_2" ~ 25,
    sample_id == "SS55_1" ~ 30,
    sample_id == "SS55_2" ~ 21,
    sample_id == "SS55_3" ~ 22,
    sample_id == "SS55_4" ~ 24,
    sample_id == "SS57_1" ~ 13,
    sample_id == "SS57_2" ~ 13,
    sample_id == "SS57_3" ~ 14,
    sample_id == "SS57_4" ~ 14,
    sample_id == "SS58_1" ~ 17,
    sample_id == "SS58_2" ~ 18,
    sample_id == "SS58_3" ~ 21,
    sample_id == "SS59_1" ~ 12,
    sample_id == "SS59_2" ~ 12,
    sample_id == "SS59_3" ~ 13, 
    sample_id == "SS59_4" ~ 14,
    sample_id == "SS59_5" ~ 14,
    sample_id == "SS59_6" ~ 14,
    sample_id == "SS68_1" ~ 15,
    sample_id == "SS68_2" ~ 16,
    sample_id == "SS68_3" ~ 17,
    sample_id == "SS69_1" ~ 12,
    sample_id == "SS69_2" ~ 13,
    sample_id == "SS69_3" ~ 14, 
    sample_id == "SS69_4" ~ 17,
    sample_id == "Z318_1" ~ 35,
    sample_id == "Z318_2" ~ 40
  )) %>%
 # filter only for the entries where number = 1 
 filter(number == 1) %>%
  mutate(occurrenceStatus = ifelse(number > 0, "present", "absent"),
         occurrenceID = " ") %>%  
  rename(eventID = sample,
         scientificName = species)
```

Third, we create an occurrence table for the third issue, _some data entries have a count > 1, and an associated range in the length measurement (i.e., 15 - 17mm)_. The next chunk of code is for the data entries where number > 1, _but_ no distinct measurement lengths are provided, but a range is provided (i.e., 15-17mm). In the code above, these entries were _not_ given an occurrenceID (but the individual measurements were); however, here we do provide an `occurrenceID` for these entries, and in the eMoF table they will have measurementTypes `minimum length` and `maximum length` to display the range. As these are all ranged values, all entries contain a hyphen so we can filter for that. 

``` {r occ_range, eval = FALSE}
# From the original dataset, filter out all the numbers in the `number` column that contain a range (i.e., a -). 
bongo_occ3 <- bongo_occ_spp %>% 
  dplyr::filter(grepl("-", bongo_occ_spp$length_mm)) %>%
  mutate(occurrenceID = " ",
         occurrenceStatus = "present") %>%
  rename(eventID = sample, 
         scientificName = species)
```

So far, for all the data entries where species have been identified to a species or genus level, we've created occurrence tables for: 

    *- Data entries where the number is not a specific number (i.e., >3, >4 and >1)
    *- Data entries where number > 1 and individual measurements are depicted in the notes
    *- Data entries where number > 1 and a range is provided in the `length_mm` column. 
    
The only occurrence table that needs to be created is for all data entries where species or genus has been identified and individual measurements are associated (i.e., the rows where number = 1):

``` {r bongo_occ_ind, eval = FALSE}
bongo_occ4 <- bongo_occ_spp %>%
  filter(number == 1) %>%
  mutate(occurrenceID = " ",
         occurrenceStatus = "present") %>%
  rename(eventID = sample,
         scientificName = species)
```

To create the final occurrence table, the four occurrence tables are joined. As individual measurements are associated to these data entries, an `occurrenceID` is created for them. Additionally, for each species the proper scientificNameID (WoRMS URN) is provided. 

After a brief discussion with Julian, it was agreed on that entries where Species = `Size fraction`, will not have an Occurrence Core associated to it, because it is not possible to associate a URN from WoRMS to this class or group (`Zooplankton`). The same goes for entries where no common rank can be associated, such as `Jellyfish, radiolarian, chaetognath` and `Gelatinous`. For other entries where no clear classification is provided, e.g. `crab zoea` and `jelly mass`, the lowest common rank URN is listed. 

``` {r bongo_combined_occ, eval = FALSE}
# Next, combine bongo_occ_wr with the original dataframe (bongo)
bongo_occ_fnl <- rbind(bongo_occ1, bongo_occ2, bongo_occ3, bongo_occ4) %>%
  select(eventID, occurrenceID, occurrenceStatus, scientificName, preservation)
bongo_occ_fnl$eventID <- stringr::str_sort(bongo_occ_fnl$eventID, numeric = TRUE)
bongo_occ_fnl <- bongo_occ_fnl %>%
  mutate(occurrenceID = paste("IYS_GoA2019_zocc", row_number(), sep = ""),
  scientificNameID = case_when(
      scientificName == "Thysanoessa spinifera" ~ "urn:lsid:marinespecies.org:taxname:237874", 
      scientificName == "Sergestes similis" ~ "urn:lsid:marinespecies.org:taxname:514127",
      # Accepted name is Eusergestes similis
      scientificName == "Euphausia pacifica" ~ "urn:lsid:marinespecies.org:taxname:237851",
      scientificName == "Salpa aspera" ~ "urn:lsid:marinespecies.org:taxname:137270",
      scientificName == "Copepod" ~ "urn:lsid:marinespecies.org:taxname:1080",
      # Subclass: Copepoda
      scientificName == "Neocalanus cristatus" ~ "urn:lsid:marinespecies.org:taxname:104470" ,
      scientificName == "Cyphocaris" ~ "urn:lsid:marinespecies.org:taxname:101603",
      scientificName == "Squat lobster" ~ "urn:lsid:marinespecies.org:taxname:106671",
      # Unsure whether the squat lobster is part of the superfamily Chirostyloidea or Galatheoidea, so the lowest common rank (InfraOrder) of Anomura was chosen. 
      scientificName == "Siphonophore" ~ "urn:lsid:marinespecies.org:taxname:1371",
      scientificName == "Chaetognath (Sagitta)" ~ "urn:lsid:marinespecies.org:taxname:5949",
      # Chaetognatha - class: Sagittoidea
      scientificName == "Beroe sp." ~ "urn:lsid:marinespecies.org:taxname:1434803",
      scientificName == "Euphausiid" ~ "urn:lsid:marinespecies.org:taxname:110671",
      # Family: Euphasiidae
      scientificName == "Chaetognath & Ctenophore" ~ "urn:lsid:marinespecies.org:taxname:2",
      # Rank: Kingdom is the lowest common rank of phylum 'chaetognatha and 'ctenophora'
      scientificName == "Siphonophore (Lensia type)" ~ "urn:lsid:marinespecies.org:taxname:135365",
      scientificName == "Aequorea sp." ~ "urn:lsid:marinespecies.org:taxname:116998",
      scientificName == "Jelly mass" ~ "urn:lsid:marinespecies.org:taxname:1267",
      # URN for 'Jelly mass' is that for phylum: Cnidaria
      scientificName == "Radiolarians" ~ "urn:lsid:marinespecies.org:taxname:582421",
      # Phylum: Radiozoa
      scientificName == "Paraphronima (gracilis)" ~ "urn:lsid:marinespecies.org:taxname:236597",
      scientificName == "Crab zoea" ~ "urn:lsid:marinespecies.org:taxname:1065",
      # URN for 'crab zoea' is that for phylum: Arthropoda. 
      scientificName == "Microstomus pacificus" ~ "urn:lsid:marinespecies.org:taxname:274294",
      scientificName == "Thysanoessa (longipes)" ~ "urn:lsid:marinespecies.org:taxname:237873",
      scientificName == "Myctophid larva" ~ "urn:lsid:marinespecies.org:taxname:125498",
      # Family: Myctophidae
      scientificName == "Primno pacifica" ~ "urn:lsid:marinespecies.org:taxname:286539",
      # Genus: Primnoa
      scientificName == "Japatella diaphana" ~ "urn:lsid:marinespecies.org:taxname:138849",
      # Genus: Japetella
      scientificName == "Clio pyrimidata" ~ "urn:lsid:marinespecies.org:taxname:139033",
      # Species: Clio pyramidata
      scientificName == "Paraeuchaeta sp." ~ "urn:lsid:marinespecies.org:taxname:196874",
      scientificName == "Thysanoessa sp." ~ "urn:lsid:marinespecies.org:taxname:110679",
      scientificName == "Gastropod veliger" ~ "urn:lsid:marinespecies.org:taxname:101",
      # Class: Gastropoda - veliger are the planktonic larvae
      scientificName == "Tarletonbeania crenularis" ~ "urn:lsid:marinespecies.org:taxname:282927",
      scientificName == "Limacina helicina" ~ "urn:lsid:marinespecies.org:taxname:140223",
      scientificName == "Phronima (sedentaria)" ~ "urn:lsid:marinespecies.org:taxname:103272",
      scientificName == "Hydromedusae" ~ "urn:lsid:marinespecies.org:taxname:1337",
      # Hydromedusae belong to the Hydrozoa as a sub-class, along with the Scyphomedusae. In WoRMS, the closest accepted URN I could find is that for subclass "Hydroidolina". As I'm not sure if this is the correct one, currently the URN for Hydromedusae reflects the URN for Hydrozoa. 
      scientificName == "Siphonophore" ~ "urn:lsid:marinespecies.org:taxname:1371",
      scientificName == "siphonophore" ~ "urn:lsid:marinespecies.org:taxname:1371",
      # Order: Siphonophorae
      scientificName == "Ctenophore / jellyfish" ~ "urn:lsid:marinespecies.org:taxname:1248",
      # As they are listed under the group 'Ctenophore', the associated URN above links to this phylum.
      scientificName == "sagitta" ~ "urn:lsid:marinespecies.org:taxname:105410", 
      scientificName == "E pacifica" ~ "urn:lsid:marinespecies.org:taxname:237851",
      scientificName == "T spinifera" ~ "urn:lsid:marinespecies.org:taxname:237874"
    )
  ) %>%
  rename(Preparations = preservation) %>%
  select(eventID, occurrenceID, scientificName, scientificNameID, occurrenceStatus, Preparations)

# Make sure the folder path exists already (e.g. ./Bongo/tidy_data)
write_csv(bongo_occ_fnl, here("Bongo", "tidy_data", "bongo_occ.csv"))
drive_upload(here("Bongo", "tidy_data", "bongo_occ.csv"),
             path = " ",
             name = "bongo_occ.csv",
             overwrite = TRUE)
```



Q: Where length (mm) is e.g. 15 - 17mm, should we filter these samples from the rest and include a minimum length and maximum length column in the eMoF table?
A: Yes, initially a dataframe is created, where we have filtered for data entries that include a range in the measurement of length. In the associated eMoF table there will be two `measurementTypes` associated to length_mm: `minimum length` and `maximum length`. 


To do: For species where number > 1, but only one length measurement is given, should we assume that all the individuals have the same length measurement? _Or, alternatively, perhaps we should make `number` a variable measured, and therefore record it in the extended measurementOrFact table_?

For some reason each measurement does not have their own associated `eventID`. Where number = 7, the notes indicate that this data entry regards 8 individuals, which have been identified to species or genus: n = 1 sagitta spp., n = 5 E. pacifica and n = 2 T. spinifera. Therefore, this eventID is split into 8 unique eventIDs to capture each unique length measurement. Unfortunately, no unique weight measurements were recorded. However, as length measurements have been associated to a species or genus, we want to make sure to include these in the Occurrence Core. 


Brian's comments regarding the size fractions: _Samples were size fractions. IN some cases the 2mm and 4mm size fractions have been split out to obtain measurements f species. The sum of these measurements is the total size fraction biomass._

Q: All species that are listed as `size fraction` belong to the group "Zooplankton". How can we best represent this group according to OBIS / WoRMS standards?
A: As no species name or genus is provided, rather than creating an `occurrenceID` for these species, we link the measurements associated to this data entry directly to the `eventID`. To indicate that it does concern measurements associated to 'Zooplankton', one of the measurement parameters is the column `Group`. 

## extended measurementOrFact

In our extended measurementOrFact table(s), we associate the measurements to either the `eventID` or the `occurrenceID`, depending on whether the species was ID'd. As a first step though, we associate the _depth_ and _size fraction_ (i.e., the mesh size) to the sampleID (`eventID`). 

``` {r bongo_sampleID, eval = FALSE}
bongo_sampleID <- bongo %>% 
  select(eventID = cast, depth) %>%
  distinct(eventID, .keep_all = TRUE) %>%
  pivot_longer(cols = c(depth, size_fraction),
               names_to = "measurementType",
               values_to = "measurementValue") %>%
  mutate(measurementValue = as.character(measurementValue),
         measurementID = paste(eventID, "depth", sep = ":"),
         measurementType = recode(measurementType,
                                  depth = "seafloor depth"),
         measurementTypeID = "http://vocab.nerc.ac.uk/collection/C00/current/SCILOG/",
         measurementUnit = "m",
         measurementUnitID = "http://vocab.nerc.ac.uk/collection/P06/current/ULAA/" ) %>%
  select(measurementID, eventID, measurementType, measurementTypeID, measurementValue,
         measurementUnit, measurementUnitID)
```

Though an occurrenceID was not created for each data entry, measurements can be linked either directly to the `eventID` or through the `occurrenceID`. The following measurements are linked to either the `eventID` or `occurrenceID`: `size fraction`, `length_mm`, `length_type`, and `weight_mg`. Additional information that might in the future be included as well could be `Stage`, which reflects a lifeStage of an organism. However, because the datasheet includes a wide variety of organisms, all with different 'levels' of a lifeStage, to what extent is it necessary to choose a uniform 'coding' system for this variable?

When the species or genus has been identified, the measurements are associated to the occurrenceID. The reason for this is that URNs from [WoRMS](http://www.marinespecies.org/) can be associated to the species entries. For the entries where the `Species` are more descriptive or which haven't been able to get associated to a URN from WoRMS, the measurements are linked directly to the `eventID`. This concerns the following listed "Species": `Gelatinous`, `Jellyfish, radiolarian, chaetognath`, and `size fraction`. 

So a total of two extended measurementOrFact cores will be created; one linking to the `occurrenceIDs` and the other directly to the `eventID`. We first create the eMoF table that links directly to the `eventID`:  

``` {r eMoF, eval = FALSE}
bongo_emof <- bongo %>% filter(species %in% c("Size fraction", 
                                              "Jellyfish, radiolarian, chaetognath", "Gelatinous")) %>%
  select(eventID = sample, 
         number, size_fraction, 
         length = length_mm,
         weight = weight_mg,
         length_type)

```

When examining this dataset, we can identify three entries that we need to explore further, where number != 0. k
%>%
  mutate_all(as.character) %>%
  pivot_longer(cols = number:length_type, 
               names_to = "measurementType",
               values_to = "measurementValue") %>%
  mutate(
    measurementID = case_when(
      measurementType == "number" ~ paste(eventID, "number", sep = ":"),
      measurementType == "size_fraction" ~ paste(eventID, "size_fraction", sep = ":"),
      measurementType == "length" ~ paste(eventID, "length", sep = ":"),
      measurementType == "length_type" ~ paste(eventID, "length_type", sep = ":"),
      measurementType == "weight" ~ paste(eventID, "weight", sep = ":")
    ),
    measurementTypeID = case_when(
      measurementType == "number" ~ " ",
      measurementType == "size_fraction" ~ " ",
      measurementType == "sample_type" ~ " ",
      # samplingProtocol
      measurementType == "length" ~ "http://vocab.nerc.ac.uk/collection/S06/current/S0600015/"
      # I want to check if maybe there is a better Controlled Vocab for body size
      measurementType == "length_type" ~ " ",
      measurementType == "weight" ~ "	http://vocab.nerc.ac.uk/collection/S06/current/S0600088/",
      measurementType == "tissue" ~ " ",
      measurementType == "stage" ~ " "
    ), 
    measurementUnit = case_when(
      measurementType == "length" ~ "mm",
      measurementType == "weight" ~ "g",
      measurementType == "size_fraction" ~ "" 
      # If this is equal to mesh size
    ), 
    measurementUnitID = case_when(
      measurementUnit == "mm" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UXMM/",
      measurementUnit == "g" ~ "	http://vocab.nerc.ac.uk/collection/P06/current/UGRM/"
      measurementUnit == " "
      # Reminder: there is no NERC Controlled Vocabulary for mg, so values are formatted to 'grams'. 
      # Is size fraction equal to mesh size?
    )
    )
    )
    
    
  ))

```

```

## MeasurementOrFact

The following variables are connected to an occurrenceID in the measurementOrFact (eMoF) table: 
- size fraction
- Length (mm)
- Length type?
- Weight (mg)
# As there is no Controlled Vocabulary for mg, these values are transformed to 'grams'. 


- Stage (= lifeStage? is all NA)
- Sample type
# Perhaps sample type should be included in the Event Core under samplingProtocol? It's not a measurement but more method of analysis. 

Add a section about comments/notes associated to the measurements. 




Next step is creating the extended measurementOrFact (eMoF) table. From personal communication with the data provider (Brian Hunt) _in some cases the 2mm and 4mm size fractions have been split out to obtain measurements of species. The sum of these measurements is the total size fraction biomass_. Therefore we first have to filter out the measurements that have been split out, and sum these fractions. 

Brian indicated that this was only done for some cases in the 2mm and 4mm size fractions, so the first step is to filter out all entries where the weight has not been determined (TBD), make the weight_mg as numeric, and examine all entries where size_fraction = 2 or 4:

``` {r biomass_wrangling, eval = FALSE}
bongo_biomass <- bongo[!(bongo$weight_mg == "TBD"),]
bongo_biomass$weight_mg <- as.numeric(as.character(bongo_biomass$weight_mg))
bongo_biomass <- bongo_biomass %>% filter(size_fraction %in% c(2, 4))
```

``` {r eMoF, eval = FALSE}
bongo_measurement <- bongo %>%
  select(number, size_fraction, sample_type,
         length = length_mm,
         length_type, 
         weight = weight_mg,
         tissue, stage) %>%
  

The sample comments needed to be tidied separately (not part of the above pipe sequence) because they belong in the measurementRemarks column. I need to recreate measurementID so that the two data frames can be joined.

``` {r measurementRemarks, eval = FALSE}
bongo_measurementRemarks <- bongo %>%
  select(eventID = sample, notes) %>%
  pivot_longer(cols = notes, values_to = "measurementRemarks") %>%
  mutate(measurementID = case_when(
    name == "notes" ~ paste(eventID, "notes", sep = ":"))) %>%
  select(measurementID, measurementRemarks)

bongo_measurementOrFact <-
  bind_rows(bongo_botdepth, bongo_measurement) %>%
  left_join(bongo_measurementRemarks) %>%
  select(
    measurementID,
    eventID,
    measurementType,
    measurementTypeID,
    measurementValue,
    measurementUnit,
    measurementUnitID,
    measurementRemarks
```



