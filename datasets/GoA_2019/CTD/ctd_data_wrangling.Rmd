---
title: "CTD Data wrangle"
author: "Tim van der Stap & Julian Gan"
date: "5/1/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lubridate)
library(readxl)
library(here)
library(parsedate)
library(googledrive)
```

Download the raw data from GoogleDrive, and read from local folder:

``` {r file_download, eval = FALSE}
drive_download("https://drive.google.com/open?id=1-onECiDW02DJRIX6g4dXywtzLEqCGyce", path = here::here("CTD", "raw_data", "Data_IYS_conbined_Final.xlsx"))

sheet1 <- read_excel(here("CTD", "raw_data", "Data_IYS_conbined_Final.xlsx"), sheet = "Sheet1")
sheet2 <- read_excel(here("CTD", "raw_data", "Data_IYS_conbined_Final.xlsx"), sheet = "Sheet2", guess_max = 60000)
```

## EventCore 

The reported date / time has to get formatted to UTC in the ISO8601 extended format. Additionally, to wrangle the data into a tidy format that follows the Darwin Core Archive (DwC-A) standards and hierarchical structure, it's important to determine how many layers of `eventID` (and, consequently, `parentEventID`) the data has. In the CTD dataset, the data has four layers: "cruise", "station", "cast", and the depth at which the measurements were taken ("ndepth"). Additional columns for each of these layers are created. 

``` {r time_formatting, eval = FALSE}
sheet2 <- sheet2 %>%
  mutate(eventDate_text = str_c(YEAR, MONTH, DAY, `TIME(ship time)`, `MIN(ship time)`, sep="-"),
         eventDate = ymd_hm(eventDate_text, tz = "Asia/Kamchatka")) %>%
  mutate(eventDate = format_iso_8601(as.POSIXct(eventDate,
                                                format = "%Y-%m-%d %H:%M%:S",
                                                tz="Asia/Kamchatka")),
         eventDate = str_replace(eventDate, "\\+00:00", "Z")
         ) %>%
  mutate(cruise = "GoA2019",
         station = paste(cruise, `NO.Trawl`, sep="_Stn"),
         cast = paste(station, "cast1", sep = ":"))

model_Rinko <- sheet2 %>% select(-TEM_S, -SAL_S) %>%
  mutate(samplingInstrument = "Rinko", 
         model = paste(cast, "Rinko", sep = ":"),
         ndepth = paste(model, DEPTH, sep = ":"))

model_SBE <- sheet2 %>% select(-TEM_R:-`BOD5[ml/l]`) %>%
  mutate(samplingInstrument = "SBE911plus",
         model = paste(cast, "SBE911plus", sep = ":"),
         ndepth = paste(model, DEPTH, sep = ":"))

sheet2 <- full_join(model_Rinko, model_SBE)

# I like to reorder the dataframe on No.Trawl and depth, in ascending order.
sheet2 <- sheet2[with(sheet2, order(NO.Trawl, DEPTH)), ]
```

The longitude was recorded as positive values, however, after QC and cross-reference to other data recorded during the same cruise, it is clear that the values should be negative.

``` {r QC_Longitude, eval = FALSE}
sheet2$LON <- -sheet2$LON
```

For each of the layers of `eventID`, a data frame is created with unique eventIDs, associated parentEventIDs, and associated unique characteristics such as `eventRemarks`. In our data, we join the date to the station level, as all station-specific data was collected on a day. 

Finally, these tables get joined, and re-ordered based on `eventID`, to create the Event Core. This table gets saved locally and in the correct GoogleDrive folder.

``` {r ctd_event, eval = FALSE}
ctd_cruise <- sheet2 %>% 
  select(eventID = cruise) %>%
  distinct(eventID) %>%
  mutate(eventRemarks = "cruise")

# Join date to station
ctd_station <- sheet2 %>%
  select(eventID = station,
         parentEventID = cruise) %>% 
  distinct(eventID, .keep_all = TRUE) %>% 
  mutate(eventRemarks = "station")

ctd_cast <- sheet2 %>% 
  select(eventID = cast,
         parentEventID = station,
         eventDate,
         decimalLatitude = LAT,
         decimalLongitude = LON) %>% 
  distinct(eventID, .keep_all = TRUE) %>% 
  mutate(eventRemarks = "cast",
         footprintWKT = paste("POINT", " (", ctd_cast$decimalLongitude,
                              " ", ctd_cast$decimalLatitude, ")"))

coordinates <- obistools::calculate_centroid(ctd_cast$footprintWKT) %>% select(coordinateUncertaintyInMeters)
ctd_cast <- cbind(ctd_cast, coordinates)

ctd_model <- sheet2 %>%
  select(eventID = model,
         parentEventID = cast) %>%
  distinct(eventID, .keep_all = TRUE) %>%
  mutate(eventRemarks = "samplingInstrument")

ctd_ndepth <- sheet2 %>% 
  select(eventID = ndepth,
         parentEventID = model,
         minimumDepthInMetres = DEPTH,
         maximumDepthInMetres = DEPTH) %>% 
  distinct(eventID, .keep_all = TRUE) %>% 
  mutate(eventRemarks = "sample")

ctd_event <- bind_rows(ctd_cruise, ctd_station, ctd_cast, ctd_model, ctd_ndepth) %>% select(eventID, parentEventID:maximumDepthInMetres, coordinateUncertaintyInMeters, eventRemarks) %>% select(-footprintWKT) %>%
  mutate(type = "Event",
         geodeticDatum = "EPSG:4326",
         samplingProtocol = " ", # Link to paper DOI
         samplingEffort = " ",
         samplingSize = " ",
         samplingSizeUnit = " ")

# If you wish to re-order the Event Core, use the following code:
# order <- stringr::str_sort(ctd_event$eventID, numeric=TRUE)
# ctd_event <- ctd_event[match(order, ctd_event$eventID),]

# Save locally and in GoogleDrive
write_csv(ctd_event, here("CTD", "tidy_data", "CTD_event.csv"))
drive_upload(here("CTD", "tidy_data", "CTD_event.csv"),
             path = "https://drive.google.com/drive/u/0/folders/1-XXOPhMN4-BmhI3owM2hvaMKXEy6hEYL",
             name = "CTD_event.csv",
             overwrite = TRUE)
```

## MeasurementOrFact 

After creating the Event Core, we create an extended MeasurementOrFact (eMoF) table. An occurrence table is not created as the datasets only contain abiotic data. Therefore, measurements are linked to eventIDs. DwC-A standards work with "long" format, rather than the wide format, so we need to transpose the data. 

Our first step however is to add the column of bottom depth at each station to the extension measurementOrFact table. Please note that the `measurementTypeID` for seafloor depth is defined as "Bridge log sheets" until there is more information about how bottom depth was determined/measured (e.g., by bathymetric sensors, charts, etc.). 

``` {r seafloor, eval = FALSE}
ctd_botdepth <- sheet2 %>% 
  select(eventID = cast, `Bot. Depth`) %>%
  distinct(eventID, .keep_all = TRUE) %>%
  pivot_longer(cols = `Bot. Depth`,
               names_to = "measurementType",
               values_to = "measurementValue") %>%
  mutate(measurementValue = as.character(measurementValue),
         measurementID = paste(eventID, "depth", sep = ":"),
         measurementType = recode(measurementType,
                                  `Bot. Depth` = "seafloor depth"),
         measurementTypeID = "http://vocab.nerc.ac.uk/collection/C00/current/SCILOG/",
         measurementUnit = "m",
         measurementUnitID = "http://vocab.nerc.ac.uk/collection/P06/current/ULAA/" ) %>%
  select(measurementID, eventID, measurementType, measurementTypeID, measurementValue,
         measurementUnit, measurementUnitID)
```

We also assign sampling instrument models as a `measurementValue` and `measurementValueID` to the event layer (model): 

``` {r samplingInstrument, eval = FALSE}
ctd_samplingInstrument <- sheet2 %>%
  select(eventID = model, samplingInstrument) %>%
  pivot_longer(cols = samplingInstrument, 
               names_to = "measurementType",
               values_to = "measurementValue") %>%
  mutate(measurementValue = as.character(measurementValue),
         measurementID = paste(eventID, "SI", sep = ":"),
         measurementType = recode(measurementType,
                                  samplingInstrument = "Sampling instrument name"),
         measurementTypeID = "http://vocab.nerc.ac.uk/collection/Q01/current/Q0100002/") %>%
  mutate(measurementValueID = case_when(
         measurementValue == "SBE911plus" ~ "http://vocab.nerc.ac.uk/collection/L22/current/TOOL0058/",
         measurementValue == "Rinko" ~ " ")) %>%
  select(eventID, measurementID, measurementType, measurementTypeID, measurementValue, measurementValueID)
```

Next, we select the appropriate columns and use the pivot_longer function to transpose the data. As EC25 is measured in microSiemens/cm, which is not (yet) in NERCs controlled vocabulary, we convert this column to milliSiemens/cm. 

Additionally, turbidity is measured in FTU. From personal communication with Anna Vazhova, _FTU is the Formazine Turbidity Unit. According to ISO 7027 (Water quality - Determination of turbidity), the turbidity unit is FNU (Formazine Nephelometric Unit). The United States Environmental Protection Agency (U.S. EPA) and the World Health Organization (WHO) use the NTU (Nephelometric Turbidity Unit). The ratio between the main units of turbidity is as follows: 1 FTU (EMF in Russia) = 1 FNU = 1 NTU_. As FTU is currently not a `measurementUnit` in the NERC vocab, we have changed this `measurementUnit` to NTU.

Finally, it is important to note that 3 columns within the dataset are _not_ in-situ CTD measurements. These three columns are: `pH`, `O2 [ml/l]` and `BOD5[ml/l]` - these measurements have been done in the lab. However, they will still be included in the eMoF dataset unless instructed otherwise. 

``` {r measurement data_wrangle, eval = FALSE}
ctd_measurement <- sheet2 %>% 
  select(eventID = ndepth, 
         `TEM_R`:`BOD5[ml/l]`,
         TEM_S,
         SAL_S) %>%
  distinct(eventID, .keep_all = TRUE) %>%
  mutate(`EC25 [mS/cm]_R` = as.numeric(`EC25 [uS/cm]_R`) / 1000) %>%
  dplyr::select(-`EC25 [uS/cm]_R`) %>%
  mutate_all(as.character) %>%
  pivot_longer(cols = `TEM_R`:`EC25 [mS/cm]_R`,
               names_to = "measurementType",
               values_to = "measurementValue") %>% 
  mutate(measurementID = case_when(measurementType == "TEM_S" ~ paste(eventID,"temp_s",sep=":"),
                                   measurementType == "TEM_R" ~ paste(eventID,"temp_r",sep=":"),
                                   measurementType == "SAL_S" ~ paste(eventID,"sal_s",sep=":"),
                                   measurementType == "SAL_R" ~ paste(eventID,"sal_r",sep=":"),
                                   measurementType == "Cond. [mS/cm]_R" ~ paste(eventID,"cond_r", sep=":"),
                                   measurementType == "Density [kg/m^3]_R" ~ paste(eventID,"density", sep=":"),
                                   measurementType == "SigmaT [ ]_R" ~ paste(eventID,"sigma_t",sep=":"),
                                   measurementType == "Chl-Flu. [ppb]_R" ~ paste(eventID,"chl_flu", sep=":"),
                                   measurementType == "Chl-a [ug/l]_R" ~ paste(eventID,"chl-a", sep=":"),
                                   measurementType == "Turb-M [FTU]_R" ~ paste(eventID,"turb",sep=":"),
                                   measurementType == "DO [mg/l]_R" ~ paste(eventID,"DO_conc",sep=":"),
                                   measurementType == "Batt. [V]_R" ~ paste(eventID,"battery", sep=":"),
                                   measurementType == "pH" ~ paste(eventID,"pH",sep=":"),
                                   measurementType == "O2 [ml/l]" ~ paste(eventID,"O2",sep=":"),
                                   measurementType == "BOD5[ml/l]" ~ paste(eventID,"BOD5",sep=":"),
                                   measurementType == "DO [%]_R" ~ paste(eventID,"DO_sat",sep=":"),
                                   measurementType == "EC25 [mS/cm]_R" ~ paste(eventID,"ec25",sep=":")),
         measurementType = recode(measurementType, 
                                  `TEM_S` = "seabird_sea_water_temperature",
                                  `TEM_R` = "rinko_sea_water_temperature",
                                  `SAL_R` = "rinko_sea_water_practical_salinity",
                                  `SAL_S` = "seabird_sea_water_practical_salinity",
                                  `pH` = "pH",
                                  `O2 [ml/l]` = "concentration_of_oxygen",
                                  `Cond. [mS/cm]_R` = "sea_water_electrical_conductivity",
                                  `Density [kg/m^3]_R` = "sea_water_density",
                                  `SigmaT [ ]_R` = "sea_water_sigma_t",
                                  `Chl-Flu. [ppb]_R` = "chlorophyll_flu",
                                  `Chl-a [ug/l]_R` = "chlorophyll_a",
                                  `Turb-M [FTU]_R` = "turbidity",
                                  `DO [mg/l]_R` = "dissolved_oxygen",
                                  `Batt. [V]_R` = "battery_voltage",
                                  `BOD5[ml/l]` = "BOD5",
                                  `DO [%]_R` = "dissolved_oxygen_saturation",
                                  `EC25 [mS/cm]_R` = "EC25"),
         
         measurementTypeID = recode(measurementType, #URIs from NERC website
                                    "seabird_sea_water_temperature" = "http://vocab.nerc.ac.uk/collection/P01/current/TEMPCU01/",
                                    "rinko_sea_water_temperature" = "http://vocab.nerc.ac.uk/collection/P01/current/TEMPCU01/",
                                    "rinko_sea_water_practical_salinity" = "http://vocab.nerc.ac.uk/collection/P01/current/SSALST01/",
                                    "seabird_sea_water_practical_salinity" = "http://vocab.nerc.ac.uk/collection/P01/current/SSALST01/",
                                    "sea_water_electrical_conductivity" = "http://vocab.nerc.ac.uk/collection/P01/current/CNDCST01/",
                                    "sea_water_density" = "http://vocab.nerc.ac.uk/collection/P07/current/CFSN0393/",
                                    "sea_water_sigma_t" = "http://vocab.nerc.ac.uk/collection/P07/current/CFSN0332/",     
                                    "chlorophyll_flu" = "http://vocab.nerc.ac.uk/collection/P07/current/CFSN0705/",
                                    "chlorophyll_a" = "http://vocab.nerc.ac.uk/collection/P07/current/CFSN0705/",
                                    "turbidity" = "http://vocab.nerc.ac.uk/collection/P25/current/TURB/",
                                    "dissolved_oxygen" = "	http://vocab.nerc.ac.uk/collection/P01/current/DOXYOP01/",
                                    "battery_voltage" = "http://vocab.nerc.ac.uk/collection/S06/current/S0600163/",
                                    "pH" = 
"http://vocab.nerc.ac.uk/collection/P01/current/PHXXZZXX/",
                                    "concentration_of_oxygen" = "http://vocab.nerc.ac.uk/collection/P01/current/DOXYWITX/",
                                    "BOD5" = "http://vocab.nerc.ac.uk/collection/P01/current/BODZZZZZ/1/",
                                    "dissolved_oxygen_saturation" = "http://vocab.nerc.ac.uk/collection/P01/current/OXYSOP01/",
                                    "EC25" = "http://vocab.nerc.ac.uk/collection/P01/current/CNDCZZ01/"),
         
         measurementUnit = case_when(measurementType == "seabird_sea_water_temperature" ~ "deg C",
                                     measurementType == "rinko_sea_water_temperature" ~ "deg C",
                                     measurementType == "rinko_sea_water_practical_salinity" ~ " ",
                                     measurementType == "seabird_sea_water_practical_salinity" ~ " ",
                                     measurementType == "pH" ~ " ",
                                     measurementType == "sea_water_electrical_conductivity" ~ "mS/cm",
                                     measurementType == "sea_water_density" ~ "kg/m^3 ",
                                     measurementType == "sea_water_sigma_t" ~ "kg/m^3",
                                     measurementType == "chlorophyll_flu" ~ "ppb",
                                     measurementType == "chlorophyll_a" ~ "ug/L",
                                     # Alternatively, chlorophyll-a concentration can be reported in mg.m-3. Conversion = 1:1.
                                     measurementType == "turbidity" ~ "NTU",
                                     measurementType == "battery_voltage" ~ "V",
                                     measurementType == "dissolved_oxygen" ~ "mg/L",
                                     measurementType == "concentration_of_oxygen" ~ "ml/L ",
                                     measurementType == "BOD5" ~ "ml/L",
                                     measurementType == "dissolved_oxygen_saturation" ~ "percent",
                                     measurementType == "EC25" ~ "mS/cm"),
         
         measurementUnitID = case_when(measurementType == "seabird_sea_water_temperature" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UPAA/",
                                       measurementType == "rinko_sea_water_temperature" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UPAA/",
                                       measurementType == "rinko_sea_water_practical_salinity" ~ "http://vocab.nerc.ac.uk/collection/P06/current/PPTR/",
                                       measurementType == "seabird_sea_water_practical_salinity" ~ "http://vocab.nerc.ac.uk/collection/P06/current/PPTR/",
                                       measurementType == "sea_water_electrical_conductivity" ~ "http://vocab.nerc.ac.uk/collection/P06/current/MSCM/",
                                       measurementType == "sea_water_density" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UKMC/",
                                       measurementType == "sea_water_sigma_t" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UKMC/",
                                       measurementType == "chlorophyll_flu" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UPPB/",
                                       measurementType == "chlorophyll_a" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UGPL/",
                                       measurementType == "turbidity" ~ "http://vocab.nerc.ac.uk/collection/P06/current/USTU/",
                                       measurementType == "dissolved_oxygen" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UMGL/",
                                       measurementType == "battery_voltage" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UVLT/",
                                       measurementType == "pH" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UUPH/",
                                       measurementType == "concentration_of_oxygen" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UMLL/",
                                       measurementType == "BOD5" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UMLL/",
                                       measurementType == "dissolved_oxygen_saturation" ~ "http://vocab.nerc.ac.uk/collection/P01/current/OXYSZZ01/",
                                       measurementType == "EC25" ~ "http://vocab.nerc.ac.uk/collection/P06/current/MSCM/")
  ) %>%
  # As Rinko doesn't take measurements at depths > 600m, there are a lot of "NaN" measurementValues at each stations at depths between 600 - 1000m. These values need to be removed:
  filter(measurementValue != "NaN")

# Join the dataframes: 
ctd_measurementOrFact <- bind_rows(ctd_botdepth, ctd_samplingInstrument, ctd_measurement) %>%
  select(measurementID, eventID, measurementType, measurementTypeID,
         measurementValue, measurementValueID, measurementUnit, measurementUnitID)

# Save locally and on GoogleDrive: 
write_csv(ctd_measurementOrFact, here("CTD", "tidy_data", "CTD_measurement.csv"))
drive_upload(here("CTD", "tidy_data", "CTD_measurement.csv"),
             path = "https://drive.google.com/drive/u/0/folders/1-XXOPhMN4-BmhI3owM2hvaMKXEy6hEYL",
             name = "CTD_eMoF.csv",
             overwrite = TRUE)
```

To visualize the sampling stations in a map:

``` {r chl_visualizations, eval = FALSE}
ctd_leaflet <- obistools::plot_map_leaflet(ctd_event)
ctd_map <- obistools::plot_map(ctd_event, zoom = TRUE)
ggsave(filename = "ctd_map.png", plot = ctd_map, path = here::here("CTD", "maps"))
```