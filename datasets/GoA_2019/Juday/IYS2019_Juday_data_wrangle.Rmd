---
title: "Juday Zooplankton Data Wrangle"
author: "Tim van der Stap"
date: "1/16/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lubridate)
library(worrms)
library(obistools)
library(readxl)
library(here)
library(parsedate)
library(googledrive)
```

## Getting started

The following line only needs to be run once to download the required data sheets from Google Drive to your computer's hard drive.  

```{r drive_download}
drive_download("https://docs.google.com/spreadsheets/d/1EsvzXqBuFQo4_ne4i0NejXEkp9BkX4uG/edit#gid=515378096",
               path = here("Juday", "raw_data", "Juday Summary Data 2019.xlsx"), overwrite = TRUE)
```

These files contain [and this needs to be confirmed!] the finalized data for the zooplankton collected during the 2019 IYS Expedition. The `Juday Net Zoopl Data 2019.xlsx` file contains the raw data in different sheets, though the information is presented in Russian. The other file, `Summary of corrected zooplankton biomass.xlsx` contains the summarized biomass for different size classes. This file is in English. Initially what I will attempt is create a working (provisional) file of the summarized data (`Juday Summary Data 2019_WF.xlsx`), as this will also include information relevant to the Event Core (date, time, coordinates, sampling depth etc). All changes from the original summarized file to the working file with be recorded in the `Juday_Changelog.Rmd` file. 

This .Rmd file will include, at minimum, 6 chunks of code, as I'll be creating an Event, Occurrence and eMOF core for both the summarized and the raw data (once it's translated).

``` {r zoopl_juday, eval = FALSE}
juday <- read_excel(here("Juday", "raw_data", "Juday Summary Data 2019_WF.xlsx")) %>%
  mutate(Date = paste(Year, Month, Day, sep = "-")) %>%
  mutate(Time = format(Time, "%H:%M:%S"),
         eventDate = format_iso_8601(as.POSIXct(paste(Date, Time),
                                                format = "%Y-%m-%d %H:%M:%S",
                                                tz = "Asia/Kamchatka")),
         eventDate = str_replace(eventDate, "\\+00:00", "Z")) %>%
  mutate(project = "IYS",
         cruise = paste(project, "GoA2019", sep = ":"),
         station = paste(cruise, `GoA survey Station Number`, sep = "_Stn"),
         cast = paste(station, "juday", sep = ":")) 

juday$year <- as.numeric(format(as.Date(juday$eventDate), "%Y"))
juday$month <- as.numeric(format(as.Date(juday$eventDate), "%m"))
juday$day <- as.numeric(format(as.Date(juday$eventDate), "%d"))
```

## Create the Event core - Summarized Juday data

In the Event Core we include the different metadata information pertaining to the various levels. We need to ensure that the longitude falls within the range of -180 to 180 (inclusive). The `Sampling layer` column reflects the depth at which the samples were taken. 

``` {r pathogen_event, eval = FALSE}
juday_project <- juday %>%
  select(eventID = project) %>%
  distinct(eventID)

juday_cruise <- juday %>% 
  select(eventID = cruise,
         parentEventID = project) %>%
  distinct(eventID, .keep_all = TRUE)

juday_station <- juday %>%
  select(eventID = station,
         parentEventID = cruise) %>% 
  distinct(eventID, .keep_all = TRUE) 

juday_cast <- juday %>%
  select(eventID = cast,
         parentEventID = station,
         eventDate,
         year,
         month,
         day,
         decimalLatitude = Latitude,
         decimalLongitude = Longitude,
         minimumDepthInMeters = `Sampling layer`,
         maximumDepthInMeters = `Sampling layer`,
         eventRemarks = `Day/Night`) %>%
  mutate(decimalLongitude = decimalLongitude - 360) %>%
  distinct(eventID, .keep_all = TRUE) 

# To connect them all together: 
juday_event_summary <- bind_rows(juday_project,
                                 juday_cruise,
                                 juday_station,
                                 juday_cast)

# Make sure the folder path exists already (e.g. ./Salmon Diet/tidy_data)
write_csv(juday_event_summary, here("Juday", "tidy_data", "juday_event_summary.csv"))
```

## Occurrence Extension Summarized Juday Data

The Occurrence extension for the summarized Juday Zooplankton data collected during the 2019 IYS High Seas Expedition will include the taxonomic hierarchic information pertaining to the 6 zooplankton groups identified. For this to happen the table will first have to be pivoted to a long format, and filtered for those occurrences where the species or genus was identified in the Juday net.   

The species `Others` has been removed until further notice, as I cannot verify whether these observations can be grouped under a single Kingdom, in other words, I'm not sure if this only includes eg. Animalia, or also Protozoa.  

``` {r summary_juday_occ, eval = FALSE}
juday_summary_occ <- juday %>%
  select(cast,
         Copepoda:Hydromedusa) %>%
  pivot_longer(Copepoda:Hydromedusa,
               names_to = "scientificname",
               values_to = "biomass")

unique_taxa <- unique(juday_summary_occ$scientificname)
worms_check <- obistools::match_taxa(unique_taxa)
```

An initial check through the WoRMS database indicates that there is no record of 'Hydromedusa' in that registry. Hydromedusa(e) are the medusa lifestage of the species Hydrozoa. Therefore, in the unique_taxa dataframe the records of Hydromedusa are replaced with Hydrozoa, and at a later stage medusa are added as a lifeStage in the Occurrence extension and the eMOF. Make sure the record is also replaced in the juday_summary_occ dataframe as we'll be joining the two dataframes together by scientificname. 

- [ ] To do: Confirm with data providers that Hydromedusae are Hydrozoa. 

``` {r, eval = FALSE}
juday_summary_occ<-  juday_summary_occ %>%
  mutate(lifeStage = case_when(
    scientificname == "Hydromedusa" ~ "Hydromedusae"))
juday_summary_occ$scientificname <- gsub("Hydromedusa", "Hydrozoa", juday_summary_occ$scientificname)

juday_scientificnames <- worrms::wm_records_names(unique(juday_summary_occ$scientificname)) %>% dplyr::bind_rows() 

IYS2019_juday_occ <- left_join(juday_summary_occ, juday_scientificnames, by = "scientificname") %>%
  filter(biomass > 0) %>%
  rename(eventID = cast) %>%
  mutate(occurrenceStatus = "present",
         occurrenceID = paste(eventID, "jocc", row_number(), sep = ":"))
```

Then we finalize the Occurrence extension. We create a new dataframe for this, as for creating the eMOF we'll need to use `IYS2019_juday_occ`, given that this also includes information on the wet weight biomass. This information is not required in the Occurrence extension however. 

``` {r final_juday2019_occ, eval = FALSE}
Juday_occ <- IYS2019_juday_occ %>%
  rename(scientificName = scientificname,
         scientificNameID = lsid,
         taxonomicStatus = status,
         taxonRank = rank,
         scientificNameAuthorship = authority) %>%
  select(eventID, occurrenceID, occurrenceStatus, scientificName, scientificNameID, scientificNameAuthorship,
         taxonomicStatus, taxonRank, parentNameUsageID, kingdom, phylum, class, order, family, genus, lifeStage) %>%
  mutate(basisOfRecord = "PreservedSpecimen")

# Make sure the folder path exists already (e.g. ./Juday/tidy_data)
write_csv(Juday_occ, here("Juday", "tidy_data", "juday_occ_summary.csv"))
```

## extended Measurement or Fact extension Summarized Juday Data

In the follow chunk of code we add the measurements (biomass wet weight, in mg per cubic meter) associated to the different zooplankton groups and separated between different size classes. Additionally, measurements or facts related to the sampling (water volume sampled, bottom depth etc) are added also, but linked to the relevant eventID rather than occurrenceID. 

``` {r summary_juday_emof, eval = FALSE}
# First create a table with measurements related to the bottomdepth at sampling location. 
juday_bottomdepth <- juday %>%
  select(eventID = cast, 
         `Station depth`) %>%
  distinct(eventID, .keep_all = TRUE) %>%
  mutate_all(as.character) %>%
  rename(measurementValue = `Station depth`) %>%
  mutate(measurementID = paste(eventID, "depth", sep = ":"),
         measurementType = "seafloor depth",
         measurementTypeID = "http://vocab.nerc.ac.uk/collection/C00/current/SCILOG/",
         measurementUnit = "meter",
         measurementUnitID = "http://vocab.nerc.ac.uk/collection/P06/current/ULAA/") %>%
  select(eventID, measurementID, measurementType, measurementTypeID, measurementValue, 
         measurementUnit, measurementUnitID)
```

As the measurements include biomass (wet weight) per volume, we need to provide the sampling effort (water volume filtered) and other facts related to the sampling instrument and method (mesh size, speed of tow etc), and associated with the cast. From the data I gather that the "cubic meters" is 20.0, which I assume is the volume filtered.

- [ ] To do: confirm with Evgeny that this column depicts the volume filtered. 

``` {r sampling_effort_juday_sampling, eval = FALSE}
juday2019_samplingEffort <- juday %>%
  select(eventID = cast) %>%
  distinct(eventID, .keep_all = T) %>%
  mutate(volume_filtered = 20,
         mesh_size = " ",
         net_opening = " ",
         gear_type = "Juday Net",
         tow_speed = " ") %>%
  mutate_all(as.character) %>%
  pivot_longer(cols = volume_filtered:tow_speed,
               names_to = "measurementType",
               values_to = "measurementValue") %>%
  mutate(measurementID = paste(eventID, measurementType, sep = ":"),
         measurementTypeID = case_when(
           measurementType == "volume_filtered" ~ "http://vocab.nerc.ac.uk/collection/P01/current/VOLWBSMP/",
           measurementType == "mesh_size" ~ "http://vocab.nerc.ac.uk/collection/Q01/current/Q0100015/",
           measurementType == "net_opening" ~ "http://vocab.nerc.ac.uk/collection/Q01/current/Q0100017/",
           measurementType == "gear_type" ~ "http://vocab.nerc.ac.uk/collection/Q01/current/Q0100002/",
           measurementType == "tow_speed" ~ "http://vocab.nerc.ac.uk/collection/P01/current/TOWSPEED/"),
         measurementUnit = case_when(
           measurementType == "volume_filtered" ~ "cubic meter",
           measurementType == "mesh_size" ~ "micrometer",
           measurementType == "tow_speed" ~ " ",
           measurementType == "net_opening" ~ "square meter"),
         measurementUnitID = case_when(
           measurementUnit == "cubic meter" ~ "",
           measurementUnit == "micrometer" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UMIC/",
           measurementUnit == "square meter" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UMSQ/"),
         measurementValueID = case_when(
           measurementValue == "Juday Net" ~ " ")) %>%
    select(eventID, measurementID, measurementType, measurementTypeID, measurementValue, measurementValueID,
         measurementUnit, measurementUnitID)
```

Next, create a measurement table for biomass measumrents related to specific zooplankton groups. Please note that information related to the different size classes is not included in this eMOF, not sure how best to approach adding those data as well. 

``` {r juday2019_emof, eval = FALSE}
juday_emof_spp <- IYS2019_juday_occ %>%
  select(eventID, 
         occurrenceID, 
         biomass) %>%
  rename(measurementValue = biomass) %>%
  mutate(measurementType = "biomass",
         measurementTypeID = "http://vocab.nerc.ac.uk/collection/P01/current/SDBIOL04/",
         measurementID = paste(occurrenceID, measurementType, sep = "-"),
         measurementUnit = "milligrams per cubic meter",
         measurementUnitID = "http://vocab.nerc.ac.uk/collection/P06/current/UMMC/") %>%
  select(measurementID, measurementType, measurementTypeID,
         measurementValue, measurementUnit, measurementUnitID)

# Combine the two extended measurement or fact tables into a single core, re-order if preferred and save locally:
juday2019_emof <- plyr::rbind.fill(juday_bottomdepth, juday2019_samplingEffort, juday_emof_spp)

# If interested in re-ordering:
order <- stringr::str_sort(juday2019_emof$measurementID)
juday2019_emof <- juday2019_emof[match(order, juday2019_emof$measurementID),]

# Make sure the folder path exists already (e.g. ./Juday/tidy_data)
write_csv(juday2019_emof, here("Juday", "tidy_data", "juday_emof_summary.csv"))
```