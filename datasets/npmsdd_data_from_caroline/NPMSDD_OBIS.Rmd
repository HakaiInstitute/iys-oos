---
title: "NPMSDD_OBIS"
author: "Tim van der Stap"
date: "10/30/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

ipak <- function(pkg){
    new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
    if (length(new.pkg)) 
        install.packages(new.pkg, dependencies = TRUE)
    sapply(pkg, require, character.only = TRUE)
}

packages <- c("tidyverse", "lubridate", "devtools", "obistools", "readxl", "parsedate", "googledrive", "here")
ipak(packages) 
```

For the NPMSDD it was opted to create an Occurrence Core, rather than an Event Core with an associated Occurrence Core. The reason for this is that most data sources in the database consisted of aggregated data, with a lot of heterogeneity within geo-spatial scale. Therefore, if only a single time and spatial frame was associated with each source, the granularity would be very low and potentially important information would be lost. Therefore, it was opted to create an Occurrence Core, and associate date, time and spatial coordinates to each occurrenceID (i.e., the capture of a salmon or identification of prey from stomach content). This way, all the geo-spatio information for each capture and identification can be recorded and no information is lost due from aggregation. 

``` {r NPMSDD_Occ, eval = FALSE}
npmsdd <- read_csv(here::here("datasets", "npmsdd_data_from_caroline", "diet_final.csv"))
npmsdd <- npmsdd %>% select(source_id, lat_min, lat_max, lon_min, lon_max, year_min, year_max, 
                            warm_cool_years, odd_even_years, season_min, season_max,
                            month_min, month_max, date_min, time_min, time_max, predator_id,
                            prey_lowest_taxonomic_level, gear_type_predator_id1, gear_type_predator_id2,
                            gear_type_predator_id3, gear_type_predator_id4, gear_type_predator_id5)

#importing predator (salmon) and prey biological data
pred_bio <- read_csv("predator_biological_data.csv", col_types = "iiiiccccccccttnnnncccciiiiiicccnnnnnnicciciiiiiccnnnnnc") %>% 
  select(predator_id, predator_lowest_taxonomic_level) %>%
  distinct()

prey_bio <- prey_bio <- read_csv("prey_biological_data.csv", col_types = "iiiiiccccccccttnnnncccciiiiiicccnnnnnnicciciiiiicccccccccccnnnnnnciiciiiiiccnnnnnc") %>%
  select(prey_id, predator_id) 

# Join dataframes and select only for those data entries where prey has been identified (i.e. there is at least a value recorded in prey_kingdom), and where this prey can be linked to predator. 
NPMSDD_occ <- left_join(npmsdd, pred_bio, by = "predator_id") %>%
  filter(!is.na(predator_lowest_taxonomic_level)) %>%
  dplyr::rename(eventID = source_id) %>%
  mutate(eventID = paste("NPMSDD_sourceID", eventID, sep = ":"),
         eventID = paste(eventID, predator_id, sep = ":predID"),
         occurrenceStatus = "present",
         occurrenceID = paste(eventID, prey_lowest_taxonomic_level, sep = ":"),
         occurrenceID = paste(occurrenceID, "pr", sep = "-")) %>%
  dplyr::rename(scientificName = prey_lowest_taxonomic_level)

## Try to get a similar output using the obistools and taxizesoap packages:
Species <- unique(NPMSDD_occ$scientificName)
scientificnames <- obistools::match_taxa(Species)
scientificnames <- cbind(Species, scientificnames)

# Manually examine those observations where match_type is not exact, or perhaps even where no match_type is given:
manual_examination <- scientificnames %>% filter(match_type != "exact" | is.na(match_type))

ScientificNames <- worrms::wm_records_names(scientificnames$scientificName)
ScientificNames <- dplyr::bind_rows(ScientificNames) %>% filter(status == "accepted")

# Coelenterata is not added, probably because it's not listed as a marine species in WoRMS (and therefore not found through the worrms package). Manually add this species:
Coelenterata <- data.frame(
  scientificname = "Coelenterata",
  authority = NA,
  status = "nomen nudum",
  rank = "Phylum",
  parentNameUsageID = "2",
  kingdom = "Animalia",
  phylum = "Coelenterata",
  class = NA,
  order = NA,
  family = NA,
  genus = NA,
  lsid = "urn:lsid:marinespecies.org:taxname:152230"
)

ScientificNames <- plyr::rbind.fill(ScientificNames, Coelenterata)

# Upon inspection it appears there are two entries for Ctenophora. After manually inspecting them, we remove the incorrect version: 

ScientificNames <- ScientificNames[!ScientificNames$AphiaID == "163921",]
ScientificNames <- ScientificNames %>% 
  dplyr::rename(scientificName = scientificname,
                taxonRank = rank,
                scientificNameID = lsid,
                taxonomicStatus = status,
                scientificNameAuthorship = authority) %>%
  select(scientificName, scientificNameID, scientificNameID, taxonRank, taxonomicStatus, scientificNameAuthorship,
         parentNameUsageID, kingdom, phylum, class, order, family, genus)

# Add this dataframe to the original NPMSDD_occ dataframe. 
NPMSDD_occ <- left_join(NPMSDD_occ, ScientificNames, by = "scientificName")

# Create occurrence core for the predators. Please note that no columns are provided for kingdom, phylum, class, order, family, genus or species. Therefore these have to be added manually:

predator_occ <- NPMSDD_occ %>% 
  dplyr::select(eventID, predator_lowest_taxonomic_level, predator_id, lat_min, lat_max, lon_min, lon_max, 
                year_min, year_max, warm_cool_years, odd_even_years, season_min, season_max, 
                month_min, month_max, date_min, time_min, time_max, gear_type_predator_id1, gear_type_predator_id2,
                gear_type_predator_id3, gear_type_predator_id4, gear_type_predator_id5) %>%
  dplyr::rename(scientificName = predator_lowest_taxonomic_level) %>%
  mutate(occurrenceStatus = "present",
         occurrenceID = paste(eventID, "p", sep = "-"))

NPMSDD_predator <- unique(predator_occ$scientificName)
scientificnames_predator <- obistools::match_taxa(NPMSDD_predator)
scientificnames_predator <- cbind(NPMSDD_predator, scientificnames_predator)

ScientificNames_predator <- worrms::wm_records_names(scientificnames_predator$scientificName)
ScientificNames_predator <- dplyr::bind_rows(ScientificNames_predator) %>% filter(status == "accepted")

ScientificNames_predator <- ScientificNames_predator %>% 
  dplyr::rename(scientificName = scientificname,
                taxonRank = rank,
                scientificNameID = lsid,
                taxonomicStatus = status,
                scientificNameAuthorship = authority) %>%
  select(scientificName, scientificNameID, scientificNameID, taxonRank, taxonomicStatus, scientificNameAuthorship,
         parentNameUsageID, kingdom, phylum, class, order, family, genus)

predator_occ <- left_join(predator_occ, ScientificNames_predator, by = "scientificName") %>% 
  dplyr::select(eventID, occurrenceID, occurrenceStatus, lat_min, lat_max, lon_min, lon_max, year_min, year_max, 
                            season_min, season_max,month_min, month_max, date_min, time_min, time_max, scientificName,
                            scientificNameID, kingdom, phylum, class, order,family, genus, parentNameUsageID,
                            scientificNameAuthorship, taxonomicStatus, taxonRank,gear_type_predator_id1,
                            gear_type_predator_id2, gear_type_predator_id3, gear_type_predator_id4,
                            gear_type_predator_id5) %>% distinct()
predator_occ$parentNameUsageID <- as.character(predator_occ$parentNameUsageID)

prey_occ <- NPMSDD_occ %>%
    dplyr::select(eventID, occurrenceID, occurrenceStatus, lat_min, lat_max, lon_min, lon_max, year_min, year_max, 
                            season_min, season_max,month_min, month_max, date_min, time_min, time_max, scientificName,
                            scientificNameID, kingdom, phylum, class, order,family, genus, parentNameUsageID, scientificNameAuthorship, taxonomicStatus, taxonRank,gear_type_predator_id1, gear_type_predator_id2, gear_type_predator_id3, gear_type_predator_id4, gear_type_predator_id5)

# Bind rows
NPMSDD_occ <- bind_rows(prey_occ, predator_occ)

# To re-order the eventID, use following code:
order <- stringr::str_sort(NPMSDD_occ$occurrenceID, numeric=TRUE)
NPMSDD_occ <- NPMSDD_occ[match(order, NPMSDD_occ$occurrenceID),]
```

After we've created the NPMSDD Occurrence Core, we can associate each `occurrenceID` with its respective spatio-temporal information:

``` {r NPMSDD_coordinates, eval = FALSE}
coordinates <- NPMSDD_occ %>%
  select(occurrenceID,lat_min, lat_max, lon_min, lon_max) %>%
  mutate(footprintWKT = " ") %>%
  mutate(lat_min = as.numeric(lat_min),
         lat_max = as.numeric(lat_max),
         lon_min = as.numeric(lon_min),
         lon_max = as.numeric(lon_max))

coordinates$lon_max <- ifelse(coordinates$lon_max >= 180, coordinates$lon_max - 360, coordinates$lon_max)
coordinates$lon_max <- ifelse(coordinates$lon_max > 0, -coordinates$lon_max, coordinates$lon_max)
coordinates$lon_min <- ifelse(coordinates$lon_min >= 180, coordinates$lon_min - 360, coordinates$lon_min)
coordinates$lon_min <- ifelse(coordinates$lon_min > 0, -coordinates$lon_min, coordinates$lon_min)

coordinates$footprintWKT <- ifelse(!is.na(coordinates$lat_max & coordinates$lon_max), "POLYGON", 
                                   ifelse(is.na(coordinates$lat_max | coordinates$lon_max), "POINT", "LINESTRING"))

point_coordinates <- coordinates %>% filter(footprintWKT == "POINT") %>%
mutate(footprintWKT = paste0("POINT", " (", lon_min, " ", lat_min, ")")) 
point <- obistools::calculate_centroid(point_coordinates$footprintWKT)
point <- cbind(point_coordinates, point)

polygon_coordinates <- coordinates %>% filter(footprintWKT == "POLYGON") %>%
  mutate(footprintWKT = paste("POLYGON ((", lon_min, lat_min, ",",
                                lon_min, lat_max, ",",
                                lon_max, lat_min, ",",
                                lon_max, lat_max, ",",
                                lon_min, lat_min, "))"))
polygon <- obistools::calculate_centroid(polygon_coordinates$footprintWKT)
polygon <- cbind(polygon_coordinates, polygon)

# Two datasets for LINESTRING, one where lat_max is NA, and another lon_max is NA. 
linestring_coordinates_1 <- coordinates %>% filter(footprintWKT == "LINESTRING") %>% filter(is.na(lat_max)) %>%
  mutate(footprintWKT = paste("LINESTRING (", lon_min, lat_min, ",", lon_max, lat_min, ")"))
linestring_coordinates_2 <- coordinates %>% filter(footprintWKT == "LINESTRING") %>%  filter(is.na(lon_max)) %>%
  mutate(footprintWKT = paste("LINESTRING (", lon_min, lat_min, ",", lon_min, lat_max, ")"))
linestring_coordinates <- rbind(linestring_coordinates_1, linestring_coordinates_2)
linestring <- obistools::calculate_centroid(linestring_coordinates$footprintWKT) 
linestring <- cbind(linestring_coordinates, linestring)

event_coordinates <- rbind(point, polygon, linestring) %>%
  select(footprintWKT, decimalLatitude, decimalLongitude, coordinateUncertaintyInMeters)

NPMSDD_occ <- cbind(NPMSDD_occ, event_coordinates)
```

And the associated dates and times:

``` {r NPMSDD_eventDate, eval = FALSE}
occdate <- NPMSDD_occ %>%
  select(eventID, occurrenceID, year_min, year_max, season_min, season_max,
         month_min, month_max, date_min, time_min, time_max) %>%
  mutate(month_min = case_when(
    month_min == "January" ~ "01",
    month_min == "February" ~ "02",
    month_min == "March" ~ "03",
    month_min == "April" ~ "04",
    month_min == "May" ~ "05",
    month_min == "June" ~ "06",
    month_min == "July" ~ "07",
    month_min == "August" ~ "08", 
    month_min == "September" ~ "09",
    month_min == "October" ~ "10",
    month_min == "November" ~ "11",
    month_min == "December" ~ "12"),
    month_max = case_when(
    month_max == "January" ~ "01",
    month_max == "February" ~ "02",
    month_max == "March" ~ "03",
    month_max == "April" ~ "04",
    month_max == "May" ~ "05",
    month_max == "June" ~ "06",
    month_max == "July" ~ "07",
    month_max == "August" ~ "08", 
    month_max == "September" ~ "09",
    month_max == "October" ~ "10",
    month_max == "November" ~ "11",
    month_max == "December" ~ "12"))

# Step 1: If an occurrenceID has a single associated date_min, this becomes the eventDate. Similarly, if only a year_min is provided for the occurrenceID, this becomes the eventDate. 

dates <- occdate %>% filter(!is.na(date_min)) %>% 
  mutate(year = year_min, 
         month = month_min,
         eventDate = date_min)
dates <- dates %>% 
  mutate(eventDate = as.character(eventDate))

year <- occdate %>% filter(is.na(date_min) & is.na(month_min) & is.na(year_max) & is.na(season_min)) %>%
  mutate(eventDate = year_min,
         year = year_min)

# A range in years is depicted using the following code; though it's currently not required. 
year_range <- occdate %>% filter(is.na(date_min) & !is.na(year_max) & is.na(month_min) & is.na(season_min)) %>%
  mutate(eventDate = paste(year_min, year_max, sep = " - "))

# Step 2: Months. If a date_min is not provided within every data entry for a specific sourceID, the eventDate will have to be recorded on a different granularity. The first is to remove all the eventIDs from the the dates dataframe from the original 'eventdate' dataframe. We need to make sure that if months or years are represented as a range, this is accurately displayed in eventDate. 

months <- anti_join(occdate, dates, by = "occurrenceID") %>% filter(!is.na(month_min))

months_single <- months %>% filter(is.na(year_max) & is.na(month_max)) %>% 
  mutate(eventDate = paste(year_min, month_min, sep = "-"),
         year = year_min)
month_range <- months %>% filter(is.na(year_max) & !is.na(month_max)) %>%
  mutate(eventDate = paste(year_min, month_min, sep = "-"),
         eventDate = paste(eventDate, month_max, sep = "/"),
         year = year_min)
year_range <- months %>% filter(!is.na(year_max) & is.na(month_max)) %>%
  mutate(eventDate = paste(year_min, year_max, sep = "/"),
         eventDate = paste(eventDate, month_min, sep = "-"))
month_year_range <- months %>% filter(!is.na(year_max) & !is.na(month_max)) %>%
  mutate(eventDate = paste(year_min, year_max, sep = "/"),
         eventDate = paste(eventDate, month_min, sep = "-"),
         eventDate = paste(eventDate, month_max, sep = "/"))

months <- plyr::rbind.fill(months_single, month_range, year_range, month_year_range)

seasons <- occdate %>% filter(!is.na(season_min))

season_single_year <- seasons %>% filter(is.na(year_max)) %>%
  mutate(verbatimEventDate = paste(season_min, year_min, sep = " - "),
         year = year_min)
season_years <- seasons %>% filter(!is.na(year_max)) %>%
  mutate(verbatimEventDate = paste(season_min, year_min, sep = " - "),
         verbatimEventDate = paste(verbatimEventDate, year_max, sep = "/"))

seasons <- plyr::rbind.fill(season_single_year, season_years)

date <- plyr::rbind.fill(dates, year, months, seasons) %>%
  select(occurrenceID, eventDate, verbatimEventDate, year, month)

NPMSDD_occ <- left_join(NPMSDD_occ, date, by = "occurrenceID") %>%
  select(eventID, occurrenceID, eventDate, verbatimEventDate, year, month, decimalLatitude, decimalLongitude, footprintWKT, coordinateUncertaintyInMeters, scientificName, scientificNameID, scientificNameAuthorship, parentNameUsageID, occurrenceStatus, kingdom, phylum, class, order, family, genus, taxonomicStatus, taxonRank, gear_type_predator_id1, gear_type_predator_id2, gear_type_predator_id3, gear_type_predator_id4, gear_type_predator_id5) %>%
  mutate(basisOfRecord = "HumanObservation",
         geodeticDatum = "EPSG:4326 WGS84")
```

Given that we are dealing with predator-prey data, we add an additional column `associatedTaxa` to indicate which species are predators and which are prey, and how these are linked.  

``` {r associatedTaxa, eval = FALSE}
NPMSDD_occ$associatedTaxa <-   " "
NPMSDD_occ$associatedTaxa <- ifelse(grepl("-pr", NPMSDD_occ$occurrenceID), 
paste('"prey of"', " : ", '"', NPMSDD_occ$eventID, "-p", '"', sep = ""), "")
```

Although it is not a required term in the DwC standards, minimumDepthInMeters and maximumDepthInMeters are recorded as 'missing' if not provided. The information regarding sampling depth is recorded in the `gear_type_predator` file, and - depending on what gear was used - is listed under one of the following columns: gear_depth_value, gear_depth_min, fishing_depth_value and fishing_depth_min. Therefore, to obtain the minimumDepthInMeters, first the data from the gear_type_predator dataframe is joined with our initial NPMSDD_Occ dataframe. 

``` {r sampling depth, eval = FALSE}
sampling_gears <- NPMSDD_occ %>%
  select(occurrenceID, 
         gear_type_predator_id1, gear_type_predator_id2,
         gear_type_predator_id3, gear_type_predator_id4, gear_type_predator_id5) %>%
  pivot_longer(cols = gear_type_predator_id1:gear_type_predator_id5,
               values_to = "gear_type_predator_id",
               names_to = "gear") %>%
  select(occurrenceID, gear_type_predator_id) %>%
  filter(!is.na(gear_type_predator_id)) %>%
  distinct()

sampling_depth <- read_csv(here::here("datasets", "npmsdd_data_from_caroline", "gear_type_predator.csv"), 
                 col_types = "icnnncnnncnnncnnncnnncnnncnnncc") %>% 
  select(gear_type_predator_id, gear_depth_value, gear_depth_min, fishing_depth_value, 
         fishing_depth_min, gear_depth_max, fishing_depth_max)
  
depth <- left_join(sampling_gears, sampling_depth, by = "gear_type_predator_id") %>%
  transform(minimumDepthInMeters = pmin(gear_depth_value, gear_depth_min, 
                                        fishing_depth_value, fishing_depth_min, na.rm = TRUE),
            maximumDepthInMeters = pmax(gear_depth_value, gear_depth_max, 
                                        fishing_depth_value, fishing_depth_max, na.rm = TRUE)) %>%
  group_by(occurrenceID) %>% 
  mutate(minimumDepthInMeters = min(minimumDepthInMeters),
         maximumDepthInMeters = max(maximumDepthInMeters)) %>%
  select(occurrenceID, minimumDepthInMeters, maximumDepthInMeters) %>% distinct()

NPMSDD_occ <- left_join(NPMSDD_occ, depth, by = "occurrenceID") %>%
  select(-gear_type_predator_id1:-gear_type_predator_id5)

write_csv(NPMSDD_occ, here::here("datasets", "npmsdd_data_from_caroline", 
                                  "NPMSDD_occ.csv"))
```

To save any maps etc, use the following chunk of code:

``` {r save_plots_images}
obistools::plot_map(NPMSDD_occ, zoom = TRUE)
ggsave(here::here("datasets", "npmsdd_data_from_caroline", "NPMSDD_occurrence.png"))
```

To do: add in some fail safes. Furthermore, an extended Measurement Or Fact (eMOF) Core can be added as well, linking to the `occurrenceID`. Information in the eMOF core can be i.e. length and weight measurements associated to both the predators and the prey. 

``` {r fail safes, eval = FALSE}
# Ensure that occurrenceIDs are unique (i.e. no duplicates):
NPMSDD_occ[dupliated(NPMSDD_occ$occurrenceID),]

# Ensure that all occurrenceIDs have an associated eventDate:
missing_eventDate <- NPMSDD_occ[is.na(NPMSDD_occ$eventDate),]

```

