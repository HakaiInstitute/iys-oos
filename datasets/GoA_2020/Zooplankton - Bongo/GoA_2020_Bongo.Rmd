---
title: "GoA 2020 Bongo"
author: "Tim van der Stap"
date: "12/1/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
library(tidyverse)
library(lubridate)
library(worrms)
library(dplyr)
library(obistools)
library(taxizesoap)
library(readxl)
library(parsedate)
library(googledrive)
library(here)
```

## Getting started

The following line only needs to be run once to download the tidied data from Google Drive to your computer's hard drive

```{r drive_download}
# Make sure your folder path exists already (e.g. ./POM/raw_data)
drive_download("https://docs.google.com/spreadsheets/d/1DGyFTMc1jUmrKsAnH_17GiAbstMO0uYc/edit#gid=1513148710", path = here("Zooplankton - Bongo", "raw_data", "Bongo.xlsx"), overwrite = TRUE)

drive_download("https://docs.google.com/spreadsheets/d/1q0tGPJSORKEUdfad4ijzO-Ks1JRFbGTg/edit#gid=782668911", path = 
                 here("Zooplankton - Bongo", "raw_data", "Bongo_taxa.xlsx"), overwrite = T)
```

Now we need to read in the Excel file and the correct sheets we want to work with. In the Excel file there are two sheets that we want to work with, one that includes additional metadata information, such as data on tow distance and volume of water filtered, whereas the other sheet includes taxonomic occurrences of Zooplankton in the bongo net used in the isotope/fatty acid analysis. The third file includes data on the community composition or abundance study. Three files in total are downloaded and read into three separate data files:

_bongo2020_metadata_ includes the metadata associated with the 2020 Bongo Zooplankton sampling.
_bongo2020_data_ includes the dry weight and length measurements from Net 2.
_bongo2020_taxa_ includes the data for the abundance or community composition study from Net 1. 



``` {r read_file, warning = FALSE}
bongo2020_metadata <- read_excel(here("Zooplankton - Bongo", "raw_data", "Bongo.xlsx"), sheet = "Bongo metadata")
bongo2020_data <- read_excel(here("Zooplankton - Bongo", "raw_data", "Bongo.xlsx"), sheet = "Animal samples")
bongo2020_taxa<- read_excel(here("Zooplankton - Bongo", "raw_data", "Bongo_taxa.xlsx"), sheet = "All data")
```

Next we start with creating the Event Core for this Bongo dataset. Please note that the time is recorded in _PDT_, so we need to convert that to UTC through the format_iso_8601 function. In the metadata file, the values in the station column have to be changed slightly because they reflect both numbers and characters. When changing them all to characters, numbers are changed to 1.0 instead of 1.   

``` {r bongo2020, warning = FALSE}
bongo2020 <- bongo2020_data %>% filter(Gear == "Bongo") %>%
  mutate(project = "IYS",
         cruise = paste(project, "GoA2020", sep = ":"),
         station = paste(cruise, Station, sep = "_Stn:"),
         cast = paste(station, Net, sep = ":bongo:Net"))

bongo2020[2] <- lapply(bongo2020[2], function (x) {
  x1 <- type.convert(as.character(x), as.is = TRUE)
  ifelse(grepl("^[0-9.]+$", x1), round(as.numeric(x1)), x1)}
)

bongo2020_metadata <- bongo2020_metadata %>%
  mutate(Time = format(Time, "%H:%M:%S"),
         eventDate = format_iso_8601(as.POSIXct(paste(Date, Time), 
                                                format = "%Y-%m-%d %H:%M:%S",
                                                tz = "America/Los_Angeles")),
         eventDate = str_replace(eventDate, "\\+00:00", "Z"),
         project = "IYS",
         cruise = paste(project, "GoA2020", sep = ":"),
         station = paste(cruise, Station, sep = "_Stn:"),
         cast = paste(station, `Net number`, sep = ":bongo:Net"))

bongo2020_metadata[2] <- lapply(bongo2020_metadata[2], function (x) {
  x1 <- type.convert(as.character(x), as.is = TRUE)
  ifelse(grepl("^[0-9.]+$", x1), round(as.numeric(x1)), x1)}
)

bongo2020_metadata$year <- as.numeric(format(as.Date(bongo2020_metadata$eventDate), "%Y"))
bongo2020_metadata$month <- as.numeric(format(as.Date(bongo2020_metadata$eventDate), "%m"))
bongo2020_metadata$day <- as.numeric(format(as.Date(bongo2020_metadata$eventDate), "%d"))
```

## Event Core

The event Core consists of a hierarchical structure with four layers: `project`, `cruise`, `station` and `cast`. Each layer has different information associated to it:

``` {r bongo2020_event}
bongo2020_project <- bongo2020 %>%
  select(eventID = project) %>%
  distinct(eventID)

bongo2020_cruise <- bongo2020 %>%
  select(eventID = cruise,
         parentEventID = project) %>%
  distinct(eventID, .keep_all = TRUE) 

bongo2020_station <- bongo2020 %>%
  select(eventID = station,
         parentEventID = cruise) %>%
  distinct(eventID, .keep_all = TRUE)

bongo2020_cast <- bongo2020_metadata %>%
  select(eventID = cast,
         parentEventID = station,
         eventDate,
         decimalLatitude = Latitude,
         decimalLongitude = Longitude,
         minimumDepthInMetres = `Sample depth_m`,
         maximumDepthInMetres = `Sample depth_m`,
         # Not sure if sampleSizeValue should be included. 
         sampleSizeValue = `Flowmeter Volume Filtered_m3`,
         Notes) %>%
  mutate(sampleSizeUnit = "m^3",
         samplingProtocol = "vertical Bongo Net deployment",
         samplingEffort = "Volume sea water filtered") %>%
  distinct(eventID, .keep_all = TRUE) %>%
  rename(eventRemarks = Notes)

bongo2020_cast <- bongo2020_cast %>%
         mutate(footprintWKT = paste("POINT"," (", bongo2020_cast$decimalLongitude, " ", 
                                     bongo2020_cast$decimalLatitude, ")"))

coordinates <- obistools::calculate_centroid(bongo2020_cast$footprintWKT) %>% select(coordinateUncertaintyInMeters)
bongo2020_cast <- cbind(bongo2020_cast, coordinates)

bongo2020_event <- bind_rows(bongo2020_project,
                             bongo2020_cruise,
                             bongo2020_station,
                             bongo2020_cast) %>% 
  mutate(type = "PreservedSpecimen",
         geodeticDatum = "EPSG:4326 WGS84")

# Check to make sure that all parentEventIDs have a corresponding eventID, and then flatten the data:
obistools::check_eventids(bongo2020_event)
bongo2020_event <- obistools::flatten_event(bongo2020_event)

# Make sure the folder path exists already (e.g. ./Bongo/tidy_data)
write_csv(bongo2020_event, here("Zooplankton - Bongo", "tidy_data", "bongo2020_event.csv"))
drive_upload(here("Zooplankton - Bongo", "tidy_data", "bongo2020_event.csv"),
             path = " ",
             name = "bongo2020_eventCore.csv",
             overwrite = TRUE)
```

Now that the event core has been created, next we focus on the occurrence Cores. Where possible we identify to the lowest common taxonomic rank, and if applicable add species under `vernacularName`. If no taxonomic rank can be assigned to species entry (i.e. `gelatinous spp.`), try to contact the data provider to see if they can provide more taxonomic resolution, otherwise _do not_ associate measurements to an `occurrenceID` but rather to the event Core. 

Similar to what was done for the 2019 data, we need to ensure that all recorded data have their own row. What I mean by this, is that for some Sample IDs there are numerous length measurements, and a number > 1. These have to get their own data entry row. 

Lets first create an Occurrence Core for the (estimated) abundance data. The abundance data file also includes data from 2019 so we need to filter out only the data collected during the 2020 High Seas Expedition. Additionally, the `station` column is saved in such a way that the stations are listed as both numbers and character (e.g. AB). As the column currently has the class 'character', station numbers are recorded as 1.0 instead of 1. We need to fix this as well. 

``` {r bongo2020_taxa_occ, eval = FALSE}
bongo2020_taxa$date <- as.Date(bongo2020_taxa$date)
bongo2020_taxa <- subset(bongo2020_taxa, date >= "2020-03-12" & date <= "2020-04-04")
bongo2020_abun <- bongo2020_taxa %>%
  mutate(Time = format(time, "%H:%M:%S"),
         eventDate = format_iso_8601(as.POSIXct(paste(date, Time),
                                                format = "%Y-%m-%d %H:%M:%S",
                                                tz = "America/Los_Angeles")),
         eventDate = str_replace(eventDate, "\\+00:00", "Z"),
         project = "IYS",
         cruise = paste(project, "GoA2020", sep = ":"))

bongo2020_abun[1] <- lapply(bongo2020_abun[1], function (x) {
  x1 <- type.convert(as.character(x), as.is = TRUE)
  ifelse(grepl("^[0-9.]+$", x1), round(as.numeric(x1)), x1)}
)

bongo2020_abun <- bongo2020_abun %>% 
  mutate(station = paste(cruise, station, sep = "_Stn:"),
         cast = paste(station, "1", sep = ":bongo:Net"))

# Manual inspection of this dataframe shows that there are still a few species that will need slight changes in their spelling, as the worrms package does not recognize 'sp.' etc. Additionally, some ids contain a lifestage (larvae, egg etc). These are also mentioned in a column 'lifestage', so they are removed from the species id. These manual changes are listed below and are not made in the raw data file. This way the original species description is still provided. 
bongo2020_abun$id <- gsub("\\b sp.\\b", "", bongo2020_abun$id)
bongo2020_abun$id <- gsub("egg|nauplius|larva|naplius|calyptopsis|furcillia", "", bongo2020_abun$id)

bongo2020_abun <- bongo2020_abun %>% rename(scientificname = id)
worms_id <- worrms::wm_records_names(unique(bongo2020_abun$scientificname), marine_only = FALSE) %>% dplyr::bind_rows()

# Find out which species are not found in the WoRMS database:
no_worms_id <- left_join(bongo2020_abun, worms_id, by = "scientificname") %>% filter(is.na(AphiaID)) %>% distinct(scientificname)

# These species will need to have their names changed in the original dataframe (bongo2020_abun) which we'll do below. I write this out so it is clear which names or species observations have been altered, so this can be verified. 
bongo2020_abun$scientificname <- gsub("Chaetognath", "Chaetognatha", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Cununidae", "Cuninidae", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Rhynchonereella angellini", "Rhynchonereella angelini",
                                      bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Disconchoecia elegans", "Discoconchoecia elegans", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Euphausiid ", "Euphausiidae", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Doliolid", "Doliolidae", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Oikopleura labradoriensis", "Oikopleura (Vexillaria) labradoriensis",
                                      bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Copepod ", "Copepoda", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Mesocalanus tenucornis", "Mesocalanus tenuicornis", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Oikopleura dioica", "Oikopleura (Vexillaria) dioica",
                                      bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Ophuroidea", "Ophiuroidea", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Scaphocalanus brevicaudatus", "Scaphocalanus brevicornis",
                                      bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Siphonophore", "Siphonophorae", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Polychaete", "Polychaeta", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Trochophore", " ", bongo2020_abun$scientificname) # this is a lifestage.
bongo2020_abun$scientificname <- gsub("Fish |Fish", "Pisces", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Muggiae atlantica", "Muggiaea atlantica", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Gastropod", "Gastropoda", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Squid", "Teuthida", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Epicarid isopod", "Epicaridea", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Tessarabrachion occulatum", "Tessarabrachion oculatum",
                                      bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Bivalve", "Bivalvia", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Symbolophorous californiensis", "Symbolophorus californiensis",
                                      bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Aglama elegans", "Agalma elegans", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Calanoid A", "Calanoida", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Stenobrachius leucropsarus", "Stenobrachius leucopsarus",
                                      bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Nematode", "Nematoda", bongo2020_abun$scientificname)
bongo2020_abun$scientificname <- gsub("Psuedosagitta scrippsae", "Pseudosagitta scrippsae", bongo2020_abun$scientificname)
# Because I changed Chaetognath earlier, it changed the code below which I had to alter. (rewrite this). 
bongo2020_abun$scientificname <- gsub("Chaetognatha sp. (no heads)", "Chaetognatha", bongo2020_abun$scientificname, fixed = TRUE)

# As we have now changed all the names in the original dataframe (bongo2019_abun) to fit the entries in the WoRMS database registry, we can use worrms::wm_records_names() again to find all the taxonomic information. 
bongo2020_worms_id <- worrms::wm_records_names(unique(bongo2020_abun$scientificname), marine_only = FALSE) %>%
  dplyr::bind_rows()

# After manual inspection, there are some AphiaIDs that need to be removed
bongo2020_worms_id <- filter(bongo2020_worms_id, !(AphiaID %in% c("138835", "605966", "534090")))

# Check to see if we missed any:
unique_taxa <- as.data.frame(unique(bongo2020_abun$scientificname))
names(unique_taxa)[1] <- "scientificname"
temp_taxa <- left_join(unique_taxa, bongo2020_worms_id) %>% filter(is.na(AphiaID))

# Merge this dataset back into original dataframe. First remove the column "genus" from bongo2019_abun, because otherwise this one is copied. 
bongo2020_abun <- bongo2020_abun %>% select(-genus)
bongo2020_abun <- left_join(bongo2020_abun, bongo2020_worms_id, by = "scientificname") %>%
  mutate(occurrenceID = paste(station, "bongo_occ", row_number(), sep = ":"),
         occurrenceStatus = "present")
bongo2020_taxa_abundance <- bongo2020_abun %>%
  select(eventID = station,
         occurrenceID,
         occurrenceStatus,
         scientificName = scientificname,
         scientificNameID = lsid,
         organismQuantity = ind_counted,
         scientificAuthorityName = authority,
         taxonRank = rank,
         taxonomicStatus = status,
         lifeStage = stage,
         sex,
         parentNameUsageID, kingdom, phylum, class, order, family, genus) 

# Make sure the folder path exists already (e.g. ./Bongo/tidy_data)
write_csv(bongo2020_taxa_abundance, here("Zooplankton - Bongo", "tidy_data", "bongo2020_taxa_occ.csv"))
```

The second Occurrence Core we create is on the data collected for the dry weight isotope and fatty acid analysis. This data is found in a different data set (`bongo2020`).

``` {r bongo2020_occ, eval = FALSE}
unique(bongo2020$Species)

# Identify all entries that would not have an WoRMS URN associated to it, and for which no common lowest taxonomic rank can be identified, nor taxonomic resolution be provided by the data provider. For species like "jelly (unknown)" and "Gelatinous spp". I checked with the data provider, and she provided me with a best guess. 

bongo2020_occ_spp <- bongo2020 %>% filter(!(Species %in% c("Whole net", "Size fraction")))
```

Manual inspection of the `bongo2020_occ_spp` dataframe indicates that, although there are some data entries where an alternative species is mentioned in the notes, all of these data entries do have species names associated to them. Therefore we don't have to manually change the species' name for these entries (this was the case for some entries in the 2019 bongo data). Additionally, manual inspection indicated that there are _no_ approximate values in the `Number` column (i.e., ~3, >4). 

Next we confirm that there are currently no duplicate Sample IDs in the dataframe. Once we have that confirmed, we filter for all the data entries where Number > 1 _and_ where no length range is provided. Manual inspection showed that if multiple length_mm measurements are provided, the number of length measurements provided always matched the value in the `Number` column. These entries will either have to separated into their own row with associated lenght/weight measurement. 
If a length range is provided, these data entries will need a minimumLength and maximumLength associated in the eMOF core. 
``` {r, eval = FALSE}
bongo2020_occ_spp[duplicated(bongo2020_occ_spp$`Sample ID`),] # no rows in this dataframe = no duplicates.

# Filter out the data entries where Number > 1, and where individual length measurements are provided in the length_mm column. These data entries will be treated separately and then merged back into the larger dataframe. 

bongo2020_pre_occ <- bongo2020_occ_spp %>% filter(Number > 1)
bongo2020_pre_occ1 <- bongo2020_pre_occ[grepl(",", bongo2020_pre_occ$Length_mm),]

bongo2020_occ1 <- bongo2020_pre_occ1 %>%
  mutate(Length_mm = strsplit(Length_mm, ", ")) %>%  unnest(Length_mm) %>%
  group_by(`Sample ID`) %>%
  mutate(count = seq_len(length(`Sample ID`)),
         `Sample ID` = paste(`Sample ID`, count, sep = "-"),
         Number = 1) %>%
  select(-count)

# These two dataframes will be joined, and then merged back into a dataframe (that was initially subsetted for any data entries where Number > 1). 

bongo2020_occ <- bongo2020_occ_spp[!(bongo2020_occ_spp$`Sample ID` %in% bongo2020_pre_occ1$`Sample ID`),]
bongo2020_occ <- rbind(bongo2020_occ, bongo2020_occ1)
bongo2020_occ <- bongo2020_occ[order(bongo2020_occ$Station),]

bongo2020_occ <- bongo2020_occ %>%
  rename(organismQuantity = Number,
         scientificname = Species) %>%
  mutate(organismQuantityType = "individuals",
         occurrenceID = paste(cast, `Sample ID`, sep = ":"),
         occurrenceStatus = "present")

# Next, we start the taxon matching procedure by passing our scientific names to the match_taxon() function. Checking with the data provider, gelatinous spp. and jelly (unknown) are _likely_ Doliolid spp. Remove the ( ) characteres in jelly (unknown) first because otherwise gsub function won't work. 
bongo2020_occ$scientificname <- gsub("\\b sp.\\b", "", bongo2020_occ$scientificname) 
worms_id <- worrms::wm_records_names(unique(bongo2020_occ$scientificname), marine_only = FALSE) %>% dplyr::bind_rows()

# Find out which species are not found in the WoRMS database:
no_worms_id <- left_join(bongo2020_occ, worms_id, by = "scientificname") %>% filter(is.na(AphiaID)) %>% distinct(scientificname)

# These species will need to have their names changed in the original dataframe (bongo2020_occ) which we'll do below. I write this out so it is clear which names or species observations have been altered, so this can be verified. 
bongo2020_occ$scientificname <- gsub("Squid", "Cephalopoda", bongo2020_occ$scientificname)
bongo2020_occ$scientificname <- gsub("Fish egg", "Pisces", bongo2020_occ$scientificname)
bongo2020_occ$scientificname <- gsub("Phoronima", "Phronima", bongo2020_occ$scientificname)

# As we have now changed all the names in the original dataframe (bongo2019_abun) to fit the entries in the WoRMS database registry, we can use worrms::wm_records_names() again to find all the taxonomic information. After manual inspection, there are some AphiaIDs that need to be removed
bongo2020_occ_worms_id <- worrms::wm_records_names(unique(bongo2020_occ$scientificname), marine_only = FALSE) %>%
  dplyr::bind_rows()
bongo2020_occ_worms_id <- bongo2020_occ_worms_id[!grepl("503291", bongo2020_occ_worms_id$AphiaID),]

# Merge this dataframe with the original occurrence dataframe:
bongo2020_occ <- left_join(bongo2020_occ, bongo2020_occ_worms_id, by = "scientificname")

bongo2020_occ_core <- bongo2020_occ %>%
  select(cast, occurrenceID, occurrenceStatus, 
         scientificName = scientificname, 
         scientificNameID = lsid, 
         authority, kingdom, 
         phylum, class, order, family, genus, Stage, organismQuantity, organismQuantityType, Notes, Preservation) %>%
  rename(eventID = cast,
         occurrenceRemarks = Notes,
         preparations = Preservation,
         scientificNameAuthorship = authority)

# Add any caveats to species identification:
bongo2020_occ_core <- bongo2020_occ_core %>%
  mutate(vernacularName = case_when(
      occurrenceID == "GoA2020_Stn:Y27:bongo:Net2:G85" ~ "Jelly (unknown)"),
    identificationQualifier = case_when(
      scientificName == "Doliolida" ~ "This species identification is a best guess by Natalie M."
    ))

# Make sure the folder path exists already (e.g. ./Bongo/tidy_data)
write_csv(bongo2020_occ_core, here("Zooplankton - Bongo", "tidy_data", "bongo2020_occurrence.csv"))
drive_upload(here("Zooplankton - Bongo", "tidy_data", "bongo2020_occurrence.csv"),
             path = " ",
             name = "bongo2020_occCore.csv",
             overwrite = TRUE)
```

## extended measurementOrFact

In our extended measurementOrFact table(s), we associate the measurements to either the `eventID` (if species does not have an associated WoRMS URN), or the `occurrenceID` (if species has WoRMS URN). 

As a first step though, we associate the _seafloor depth_, _sampling depth_, _sampleSizeValue_ and _sampleSizeUnit_ to the cast. There is still debate on whether the sampleSizeValue and sampleSizeUnit need to be included, as we are essentially recording metadata in the data. Do note that that this Core standards for measurements and _facts_, and these Bongo net details are _facts_ linked to the Event. For the time being therefore, this information is recorded in this Core. 

``` {r bongo_bottomdepth, eval = FALSE}
bongo2020_bottomdepth <- bongo2020 %>% 
  select(eventID = cast, 
         Depth_m) %>%
  distinct(eventID, .keep_all = TRUE) %>%
  mutate_all(as.character) %>%
  pivot_longer(cols = Depth_m,
               names_to = "measurementType",
               values_to = "measurementValue") %>%
  mutate(measurementType = recode(measurementType,
                                 Depth_m = "seafloor depth"),
         measurementID = case_when(
    measurementType == "seafloor depth" ~ paste(eventID, "seafloor_depth", sep = ":"))) %>%
  mutate(measurementTypeID = case_when(
    measurementType == "seafloor depth" ~ "http://vocab.nerc.ac.uk/collection/C00/current/SCILOG/"),
        measurementUnit = case_when(
    measurementType == "seafloor depth" ~ "m"),
        measurementUnitID = case_when(
    measurementUnit == "m" ~ "http://vocab.nerc.ac.uk/collection/P06/current/ULAA/")) %>%
  select(eventID, measurementID, measurementType, measurementTypeID, measurementValue, 
         measurementUnit, measurementUnitID)
```


``` {r sampling effort, eval = FALSE}
bongo2020_sampling <- bongo2020_meta %>%
  select(eventID = cast, 
         `Tow Distance_m`,
         `Flowmeter Volume Filtered_m3`,
         `Depth estimated Volume filtered_m3`) %>%
  mutate(speed_tow = 1) %>%
  distinct(eventID, .keep_all = TRUE) %>%
  mutate_all(as.character) %>%
  pivot_longer(cols = `Tow Distance_m`:speed_tow,
               names_to = "measurementType",
               values_to = "measurementValue") %>%
  mutate(measurementType = recode(measurementType,
                                 `Tow Distance_m` = "tow_distance",
                                 `Flowmeter Volume Filtered_m3` = "volume_filtered_flowmeter",
                                 `Depth estimated Volume filtered_m3` = "volume_filtered_depth_estimate"),
         measurementID = paste(eventID, measurementType, sep = ":"),
         measurementTypeID = case_when(
           measurementType == "tow_distance" ~ "http://vocab.nerc.ac.uk/collection/P01/current/LENTRACK/",
           measurementType == "volume_filtered_flowmeter" ~ "http://vocab.nerc.ac.uk/collection/P09/current/VOLF/", 
           measurementType == "volume_filtered_depth_estimate" ~ " ",
           measurementType == "speed_tow" ~ "http://vocab.nerc.ac.uk/collection/P01/current/TOWSPEED/"
         ),
  measurementUnit = case_when(
    measurementType == "tow_distance" ~ "m",
    measurementType == "volume_filtered_flowmeter" ~ "m^3",
    measurementType == "volume_filtered_depth_estimate" ~ "m^3",
    measurementType == "speed_tow" ~ "m/s"),
  measurementUnitID = case_when(
    measurementUnit == "m" ~ "http://vocab.nerc.ac.uk/collection/P06/current/ULAA/",
    measurementUnit == "m^3" ~ "http://vocab.nerc.ac.uk/collection/P06/current/MCUB/",
    measurementUnit == "m/s" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UVAA/")) %>%
    select(eventID, measurementID, measurementType, measurementTypeID, measurementValue,
           measurementUnit, measurementUnitID)
```

Next, add information on the sampling instrument: 

The bongo had a length of 3m, but I couldn't find any controlled vocabulary for sampling instrument length so I omitted this information from the code. For the sampling instrument

``` {r samplingInstrument, eval = FALSE}
bongo2020_instrument <- bongo2020_meta %>%
  select(eventID = cast,
         Gear) %>%
  mutate(bongo_mesh = 250,
         bongo_opening = 0.5) %>%
  distinct(eventID, .keep_all = TRUE) %>%
  mutate_all(as.character) %>%
  pivot_longer(cols = Gear:bongo_opening,
               names_to = "measurementType",
               values_to = "measurementValue") %>%
  mutate(measurementID = paste(eventID, "bongo", measurementType, sep = ":"),
         measurementTypeID = case_when(
           measurementType == "Gear" ~ "http://vocab.nerc.ac.uk/collection/Q01/current/Q0100002/",
           measurementType == "bongo_mesh" ~ "http://vocab.nerc.ac.uk/collection/Q01/current/Q0100015/",
           measurementType == "bongo_opening" ~ "http://vocab.nerc.ac.uk/collection/Q01/current/Q0100017/"))

bongo2020_instrument <- bongo2020_instrument %>%
  mutate(measurementUnit = case_when(
           measurementType == "bongo_mesh" ~ "um",
           measurementType == "bongo_opening" ~ "m^2"),
         measurementUnitID = case_when(
           measurementUnit == "um" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UMIC/",
           measurementUnit == "m^2" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UMSQ/"),
         measurementValueID = case_when(
           measurementValue == "Bongo" ~ "http://vocab.nerc.ac.uk/collection/L22/current/NETT0176/")) %>%
  select(eventID, measurementID, measurementType, measurementTypeID, measurementValue,
         measurementValueID, measurementUnit, measurementUnitID)
```

Next, we create the eMOF core to associate the length and weight measurements for the individuals collected within the Bongo samples. When the species or genus has been identified, the measurements are associated to the occurrenceID.  

``` {r eMOF, eval = FALSE}
bongo2020_emof <- bongo2020_occ %>%
  select(eventID = cast,
         occurrenceID,
         length = Length_mm,
         weight = Weight_g) %>%
  mutate_all(as.character)
```

Within this dataframe, there are still the data entries that have a length measurements associated to them that's a range (i.e., 15 - 17mm). For these `occurrenceID`s we want to split this column into two, with minimumLength and maximumLength. Afterwards, that dataframe can be merged back in with bongo_emof2. 

``` {r, eval = FALSE}
range <- bongo2020_emof %>%
  # bongo_emof2 needs to be replaced with a table that contains the occurrenceIDs!!
  filter(grepl("-", bongo2020_emof$length)) %>%
  separate(col = length, into = c("minimumLength", "maximumLength"), sep = "\\-") %>%
  mutate(length = " ") # required to join dataframes at later stage. 

# Remove any rows from bongo_emof2 where length_mm contains a range, add two dummy columns (minimumLength and maximumLength) and use rbind() to merge `range` with this newly created dataframe.
temp <- bongo2020_emof[ -grep("-", bongo2020_emof$length), ] %>%
  mutate(minimumLength = " ",
         maximumLength = " ")

bongo2020_emof_fnl <- rbind(range, temp)
```

So now we have a dataframe where:
    * Species have been identified to a species or genus level
    * Length measurement ranges have been split up into columns of minimumLength and maximumLength.
    
The following columns of the original raw dataframe are not included, as I'm not sure if these would actually be considered measurements or facts:
* sample_type
* Group
* Size_fraction

``` {r, eval = FALSE}
bongo2020_emof_fnl <- bongo2020_emof_fnl %>%
  mutate_all(as.character) %>%
  pivot_longer(cols = minimumLength:length, ,
               names_to = "measurementType",
               values_to = "measurementValue") %>%
  mutate(measurementID = case_when(
      measurementType == "length" ~ paste(occurrenceID, "length", sep = ":"),
      measurementType == "weight" ~ paste(occurrenceID, "weight", sep = ":"),
      measurementType == "maximumLength" ~ paste(occurrenceID, "maxLength", sep = ":"),
      measurementType == "minimumLength" ~ paste(occurrenceID, "minLength", sep = ":")),
    measurementTypeID = case_when(
      measurementType == "length" ~ "http://vocab.nerc.ac.uk/collection/P01/current/OBSINDLX/",
      measurementType == "maximumLength" ~ "http://vocab.nerc.ac.uk/collection/P01/current/OBSMAXLX/",
      measurementType == "minimumLength" ~ "http://vocab.nerc.ac.uk/collection/P01/current/OBSMINLX/",
      measurementType == "weight" ~ "http://vocab.nerc.ac.uk/collection/S06/current/S0600253/"), 
    measurementUnit = case_when(
      measurementType == "length" ~ "mm",
      measurementType == "minimumLength" ~ "mm",
      measurementType == "maximumLength" ~ "mm",
      measurementType == "weight" ~ "g"), 
    measurementUnitID = case_when(
      measurementUnit == "mm" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UXMM/",
      measurementUnit == "g" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UGRM/"))
```

Create the eMOF core associated with the community composition or abundance analysis:

``` {r eMOF Bongo2020 abundance, eval = FALSE}
bongo2020_emof_abun <- bongo2020_abun %>%
  select(occurrenceID, 
         stage, 
         sex, 
         ind_counted:abund_m3_depth_est) %>%
  mutate_all(as.character) %>%
  pivot_longer(cols = stage:abund_m3_depth_est,
               names_to = "measurementType",
               values_to = "measurementValue") %>%
  mutate(
    measurementID = case_when(
      measurementType == "stage" ~ paste(occurrenceID, "stage", sep = ":"),
      measurementType == "sex" ~ paste(occurrenceID, "sex", sep = ":"),
      measurementType == "ind_counted" ~ paste(occurrenceID, "ind_counted", sep = ":"),
      measurementType == "ind_total" ~ paste(occurrenceID, "ind_total", sep = ":"),
      measurementType == "abund_m3_flow_est" ~ paste(occurrenceID, "abund_flow", sep = ":"),
      measurementType == "abund_m3_depth_est" ~ paste(occurrenceID, "abund_depth", sep = ":")),
    measurementTypeID = case_when(
      measurementType == "stage" ~ "http://vocab.nerc.ac.uk/collection/P01/current/LSTAGE01/",
      measurementType == "sex" ~ "http://vocab.nerc.ac.uk/collection/P01/current/ENTSEX01/",
      measurementType == "ind_counted" ~ " ",
      measurementType == "ind_total" ~ " ",
      measurementType == "abund_m3_flow_est" ~ "http://vocab.nerc.ac.uk/collection/P01/current/SDBIOL01/",
      measurementType == "abund_m3_depth_est" ~ "http://vocab.nerc.ac.uk/collection/P01/current/SDBIOL01/"), 
    measurementUnit = case_when(
      measurementType == "ind_counted" ~ "individuals",
      measurementType == "ind_total" ~ "individuals",
      measurementType == "abund_m3_depth_est" ~ "individuals/m^3",
      measurementType == "abund_m3_flow_est" ~ "individuals/m^3"
    ), 
    measurementUnitID = case_when(
      measurementUnit == "individuals" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UUUU/", 
      measurementUnit == "individuals/m^3" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UPMM/"),
    measurementValueID = case_when(
      measurementValue == "M" ~ "http://vocab.nerc.ac.uk/collection/S10/current/S103/",
      measurementValue == "F" ~ "http://vocab.nerc.ac.uk/collection/S10/current/S102/",
      measurementValue == "adult" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1116/", 
      measurementValue == "C6" ~ " ",
      measurementValue == "C5" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1112/",
      measurementValue == "C4" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1110/",
      measurementValue == "C3" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S118/",
      measurementValue == "C2" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S117/",
      measurementValue == "C1" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S111/",
      measurementValue == "juvenile" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1127/",
      measurementValue == "calyptopsis" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1118/",
      measurementValue == "egg" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1122/",
      measurementValue == "larva" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1128/",
      measurementValue == "nauplius" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1130/",
      measurementValue == "napulius" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1130/",
      measurementValue == "zoea" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1137/",
      measurementValue == "furcillia" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1123/",
      measurementValue == "neochaete" ~ " ",
      measurementValue == "trochophore" ~ " ",
      measurementValue == "veliger" ~  " ",
      measurementValue == "paralarva" ~ " ",
      measurementValue == "eudoxid" ~ " ",
      measurementValue == "gas float" ~ " ",
      measurementValue == "<0.5mm|<1mm" ~ "http://vocab.nerc.ac.uk/collection/S11/current/S1152/"
    ))

# Finalize the eMOF core for the abundance / community composition analysis:
bongo2020_eMOF_abun <- bind_rows(bongo2020_bottomdepth, bongo2020_sampling, bongo2020_instrument,
                                 bongo2020_emof_abun)
# Make sure the folder path exists already (e.g. ./Bongo/tidy_data)
write_csv(bongo2020_eMOF_abun, here("Zooplankton - Bongo", "tidy_data", "bongo2020_eMOF_abun.csv"))
```

Finalize the extended Measurement or Fact core for the 2020 Bongo Zooplankton Length / Dry weight data. 

``` {r bongo_measurementOrFact Core, eval = FALSE}
bongo2020_measurementOrFact <- bind_rows(bongo2020_bottomdepth, bongo2020_sampling, 
                                     bongo2020_instrument, bongo2020_emof_fnl) %>%
  select(
    eventID,
    occurrenceID,
    measurementID,
    measurementType,
    measurementTypeID,
    measurementValue,
    measurementValueID,
    measurementUnit,
    measurementUnitID)

write_csv(bongo2020_measurementOrFact, here("Zooplankton - Bongo", "tidy_data", "bongo2020_measurementOrFact.csv"))
```

