---
title: "GoA 2020 Bongo"
author: "Tim van der Stap"
date: "12/1/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
library(tidyverse)
library(lubridate)
library(dplyr)
library(obistools)
library(taxizesoap)
library(readxl)
library(parsedate)
library(googledrive)
library(here)
```

## Getting started

The following line only needs to be run once to download the tidied data from Google Drive to your computer's hard drive

```{r drive_download}
# Make sure your folder path exists already (e.g. ./POM/raw_data)
drive_download("https://docs.google.com/spreadsheets/d/1DGyFTMc1jUmrKsAnH_17GiAbstMO0uYc/edit#gid=1513148710", path = here("Zooplankton - Bongo", "raw_data", "Bongo.xlsx"), overwrite = TRUE)
```

Now we need to read in the Excel file and the correct sheets we want to work with. In the Excel file there are two sheets that we want to work with, one that includes the metadata, whereas the other sheet includes taxonomic occurrences of zooplankton in the bongo net. 

``` {r read_file}
bongo2020_metadata <- read_excel(here("Zooplankton - Bongo", "raw_data", "Bongo.xlsx"), sheet = "Bongo metadata")
bongo2020_data <- read_excel(here("Zooplankton - Bongo", "raw_data", "Bongo.xlsx"), sheet = "Animal samples")
```

Next we start with creating the Event Core for this Bongo dataset. 

``` {r bongo2020}
bongo2020 <- bongo2020_data %>% filter(Gear == "Bongo") %>%
  mutate(cruise = "GoA2020",
         station = paste(cruise, Station, sep = "_Stn:"),
         cast = paste(station, Net, sep = ":bongo:Net"))

bongo2020_meta <- bongo2020_metadata %>%
  mutate(Time = format(Time, "%H:%M:%S"),
         eventDate = format_iso_8601(as.POSIXct(paste(Date, Time), 
                                                format = "%Y-%m-%d %H:%M:%S",
                                                # Time is recorded in PDT, must ensure that timezone is correct
                                                tz = "Asia/Kamchatka")),
         eventDate = str_replace(eventDate, "\\+00:00", "Z"),
         cruise = "GoA2020",
         station = paste(cruise, Station, sep = "_Stn:"),
         cast = paste(station, `Net number`, sep = ":bongo:Net"))
```

## Event Core

``` {r bongo2020_event}
bongo2020_cruise <- bongo2020 %>%
  select(eventID = cruise) %>%
  distinct(eventID) 

bongo2020_station <- bongo2020 %>%
  select(eventID = station,
         parentEventID = cruise) %>%
  distinct(eventID, .keep_all = TRUE)

bongo2020_cast <- bongo2020_meta %>%
  select(eventID = cast,
         parentEventID = station,
         eventDate,
         decimalLatitude = Latitude,
         decimalLongitude = Longitude,
         minimumDepthInMetres = `Sample depth_m`,
         maximumDepthInMetres = `Sample depth_m`,
         sampleSizeValue = `Flowmeter Volume Filtered_m3`,
         Notes) %>%
  mutate(sampleSizeUnit = "m^3",
         samplingProtocol = "vertical Bongo Net deployment",
         samplingEffort = "Volume sea water filtered") %>%
  distinct(eventID, .keep_all = TRUE) %>%
  rename(eventRemarks = Notes)

bongo2020_cast <- bongo2020_cast %>%
         mutate(footprintWKT = paste("POINT"," (", bongo2020_cast$decimalLongitude, " ", 
                                     bongo2020_cast$decimalLatitude, ")"))

coordinates <- obistools::calculate_centroid(bongo2020_cast$footprintWKT) %>% select(coordinateUncertaintyInMeters)
bongo2020_cast <- cbind(bongo2020_cast, coordinates)

bongo2020_event <- bind_rows(bongo2020_cruise,
                             bongo2020_station,
                             bongo2020_cast) %>% 
  mutate(type = "PreservedSpecimen",
         geodeticDatum = "EPSG:4326 WGS84")

# Check to make sure that all parentEventIDs have a corresponding eventID, and then flatten the data:
obistools::check_eventids(bongo2020_event)
bongo2020_event <- obistools::flatten_event(bongo2020_event)

# Make sure the folder path exists already (e.g. ./Bongo/tidy_data)
write_csv(bongo2020_event, here("Zooplankton - Bongo", "tidy_data", "bongo2020_event.csv"))
drive_upload(here("Zooplankton - Bongo", "tidy_data", "bongo2020_event.csv"),
             path = " ",
             name = "bongo2020_eventCore.csv",
             overwrite = TRUE)
```

Now that the event core has been created, next we focus on the occurrence core. The main question that we have to answer to finalize this core is:

- [ ] If a data entry cannot have an associated scientificName and scientificNameID (required terms), should they still have an associated occurrenceID? This is the case for Zooplankton: perhaps this should be classified as verbatimScientificName? or organismScope? **A** Where possible identify to the lowest common taxonomic rank, and add species under `vernacularName`. If no taxonomic rank can be assigned to species entry (i.e. `gelatinous spp.`), try to contact the data provider to see if they can provide more taxonomic resolution, otherwise _do not_ associate measurements to an `occurrenceID` but rather to the event Core. 

Similar to what was done for the 2019 data, we need to ensure that all recorded data have their own row. What I mean by this, is that for some Sample IDs there are numerous length measurements, and a number > 1. These have to get their own data entry row. 

``` {r bongo2020_occ, eval = FALSE}
unique(bongo2020$Species)

# Identify all entries that would not have an WoRMS URN associated to it, and for which no common lowest taxonomic rank can be identified, nor taxonomic resolutation be provided by the :

bongo2020_occ_spp <- bongo2020 %>% filter(!(Species %in% c("Whole net", "Size fraction", "Gelatinous spp.", "Jelly (unknown)")))
```

Manual inspection of the `bongo2020_occ_spp` dataframe indicates that, although there are some data entries where an alternative species is mentioned in the notes, all of these data entries do have species names associated to them. Therefore we don't have to manually change the species' name for these entries (this was the case for some entries in the 2019 bongo data). Additionally, manual inspection indicated that there are _no_ approximate values in the `Number` column (i.e., ~3, >4). 

Next we confirm that there are currently no duplicate Sample IDs in the dataframe. Once we have that confirmed, we filter for all the data entries where Number > 1 _and_ where no length range is provided. Manual inspection showed that if multiple length_mm measurements are provided, the number of length measurements provided always matched the value in the `Number` column. These entries will either have to separated into their own row with associated lenght/weight measurement. 

If a length range is provided, these data entries will need a minimumLength and maximumLength associated in the eMOF core. 

``` {r, eval = FALSE}
bongo2020_occ_spp[duplicated(bongo2020_occ_spp$`Sample ID`),] # no rows in this dataframe = no duplicates.

# Filter out the data entries where Number > 1, and where individual length measurements are provided in the length_mm column. These data entries will be treated separately and then merged back into the larger dataframe. 

bongo2020_pre_occ <- bongo2020_occ_spp %>% filter(Number > 1)
bongo2020_pre_occ1 <- bongo2020_pre_occ[grepl(",", bongo2020_pre_occ$Length_mm),]

bongo2020_occ1 <- bongo2020_pre_occ1 %>%
  mutate(Length_mm = strsplit(Length_mm, ", ")) %>%  unnest(Length_mm) %>%
  group_by(`Sample ID`) %>%
  mutate(count = seq_len(length(`Sample ID`)),
         `Sample ID` = paste(`Sample ID`, count, sep = "-"),
         Number = 1) %>%
  select(-count)

# These two dataframes will be joined, and then merged back into a dataframe (that was initially subsetted for any data entries where Number > 1). 

bongo2020_occ <- bongo2020_occ_spp[!(bongo2020_occ_spp$`Sample ID` %in% bongo2020_pre_occ1$`Sample ID`),]
bongo2020_occ <- rbind(bongo2020_occ, bongo2020_occ1)
bongo2020_occ <- bongo2020_occ[order(bongo2020_occ$Station),]

bongo2020_occ <- bongo2020_occ %>%
  rename(organismQuantity = Number) %>%
  mutate(organismQuantityType = "individuals",
         occurrenceID = paste(cast, `Sample ID`, sep = ":"),
         occurrenceStatus = "present")

# Next, we start the taxon matching procedure by passing our scientific names to the match_taxon() function:

Species <- unique(bongo2020_occ$Species)
scientificNames <- obistools::match_taxa(Species)
scientificNames <- cbind(Species, scientificNames)

# Merge this dataframe with the original occurrence dataframe:

bongo2020_occ <- left_join(bongo2020_occ, scientificNames, by = "Species")

# Use taxizesoap() package to derive the taxonomic data from the WoRMS-corrected scientificNames. Rename lsid to scientificNameID because we'll need that to merge the dataframe back with the original in the next step:
names_worms <- taxizesoap::worms_records(bongo2020_occ$scientificName) %>%
  select(inputid, scientificname, authority, rank, valid_name, valid_authority, kingdom, phylum,
         class, order, family, genus, lsid) %>% rename(scientificNameID = lsid)

# Merge back with original dataframe:
bongo2020_occ_full <- left_join(bongo2020_occ, names_worms, by = "scientificNameID") %>% distinct()

# As you can see there are still rows where no taxonomic data is provided for the scientificName. This is for data entries such as "Squid" and "Fish eggs". 

Species_manual <- bongo2020_occ_full[is.na(bongo2020_occ_full$scientificName),]
Species_manual <- Species_manual %>%
  mutate(kingdom = case_when(
    Species == "Squid" ~ "Animalia",
    Species == "Fish egg" ~ "Animalia",
    Species == "Jelly (unknown)" ~ "Animalia",
    phylum = case_when(
      Species == "Squid" ~ "Mollusca",
      Species == "Fish egg" ~ "Chordata",
      Species == "Jelly (unknown)" ~ "Cnidaria"),
    class = case_when(
      Species == "Squid" ~ "Cephalopoda"),
    scientificName = case_when(
      Species == "Squid" ~ "Cephalopoda",
      Species == "Fish egg" ~ "Pisces"),
    scientificNameID = case_when(
      Species == "Squid" ~ "urn:lsid:marinespecies.org:taxname:11707",
      Species == "Fish egg" ~ "urn:lsid:marinespecies.org:taxname:11676"),
    vernacularName = case_when(
      Species = "Jelly (unknown)" ~ "Jelly (unknown)"
    ))

# Remove the data entries for 'Squid' and 'fish egg' from the original occurrence core, and then add the dataframe `Species_manual` to the `bongo2020_Occ_full`. 
stripped <- bongo2020_occ_full[!bongo2020_occ_full$Species %in% c("Squid", "Fish egg"),]
bongo2020_occ_fnl <- rbind(stripped, Species_manual) # We need this dataframe for our occurrence core
bongo2020_occ_core <- bongo2020_occ_fnl %>%
  select(cast, occurrenceID, occurrenceStatus, scientificName, scientificNameID, authority, kingdom, 
         phylum, class, order, family, genus, Stage, organismQuantity, organismQuantityType, Notes, Preservation) %>%
  rename(eventID = cast,
         occurrenceRemarks = Notes
         preparations = Preservation)

# You'll notice how both scientificName and valid_name are both in there. This is because some names under scientificName are not accepted under WoRMS, in which case the accepted version is mentioned under valid_name. However, the scientificNameID still references the unaccepted version so this will need to be changed! 

# To see if there are any data entries where valid_name differs from the scientificName (QC for the accuracy of the reported species data):
difference <- bongo2020_occ_full %>% filter(!valid_name == scientificName)

# Make sure the folder path exists already (e.g. ./Bongo/tidy_data)
write_csv(bongo2020_occ_core, here("Zooplankton - Bongo", "tidy_data", "bongo2020_occurrence.csv"))
drive_upload(here("Zooplankton - Bongo", "tidy_data", "bongo2020_occurrence.csv"),
             path = " ",
             name = "bongo2020_occCore.csv",
             overwrite = TRUE)
```


## extended measurementOrFact

In our extended measurementOrFact table(s), we associate the measurements to either the `eventID` (if species does not have an associated WoRMS URN), or the `occurrenceID` (if species has WoRMS URN). 

As a first step though, we associate the _seafloor depth_, _sampling depth_, _sampleSizeValue_ and _sampleSizeUnit_ to the cast. There is still debate on whether the sampleSizeValue and sampleSizeUnit need to be included, as we are essentially recording metadata in the data. Do note that that this Core standards for measurements and _facts_, and these Bongo net details are _facts_ linked to the Event. For the time being therefore, this information is recorded in this Core. 

``` {r bongo_bottomdepth, eval = FALSE}
bongo2020_bottomdepth <- bongo2020 %>% 
  select(eventID = cast, 
         Depth_m) %>%
  distinct(eventID, .keep_all = TRUE) %>%
  mutate_all(as.character) %>%
  pivot_longer(cols = Depth_m,
               names_to = "measurementType",
               values_to = "measurementValue") %>%
  mutate(measurementType = recode(measurementType,
                                 Depth_m = "seafloor depth"),
         measurementID = case_when(
    measurementType == "seafloor depth" ~ paste(eventID, "seafloor_depth", sep = ":"))) %>%
  mutate(measurementTypeID = case_when(
    measurementType == "seafloor depth" ~ "http://vocab.nerc.ac.uk/collection/C00/current/SCILOG/"),
        measurementUnit = case_when(
    measurementType == "seafloor depth" ~ "m"),
        measurementUnitID = case_when(
    measurementUnit == "m" ~ "http://vocab.nerc.ac.uk/collection/P06/current/ULAA/")) %>%
  select(eventID, measurementID, measurementType, measurementTypeID, measurementValue, 
         measurementUnit, measurementUnitID)
```


``` {r sampling effort, eval = FALSE}
bongo2020_sampling <- bongo2020_meta %>%
  select(eventID = cast, 
         `Tow Distance_m`,
         `Flowmeter Volume Filtered_m3`) %>%
  mutate(speed_tow = 1) %>%
  distinct(eventID, .keep_all = TRUE) %>%
  mutate_all(as.character) %>%
  pivot_longer(cols = `Tow Distance_m`:speed_tow,
               names_to = "measurementType",
               values_to = "measurementValue") %>%
  mutate(measurementType = recode(measurementType,
                                 `Tow Distance_m` = "tow_distance",
                                 `Flowmeter Volume Filtered_m3` = "volume_filtered"),
         measurementID = paste(eventID, measurementType, sep = ":"),
         measurementTypeID = case_when(
           measurementType == "tow_distance" ~ "http://vocab.nerc.ac.uk/collection/P01/current/LENTRACK/",
           measurementType == "volume_filtered" ~ " ", 
           # perhaps: http://vocab.nerc.ac.uk/collection/P01/current/VOLWBSMP/ ?
           measurementType == "speed_tow" ~ "http://vocab.nerc.ac.uk/collection/P01/current/TOWSPEED/"
         ),
  measurementUnit = case_when(
    measurementType == "tow_distance" ~ "m",
    measurementType == "final_volume_filtered" ~ "m^3",
    measurementType == "speed_tow" ~ "m/s"),
  measurementUnitID = case_when(
    measurementUnit == "m" ~ "http://vocab.nerc.ac.uk/collection/P06/current/ULAA/",
    measurementUnit == "m^3" ~ "http://vocab.nerc.ac.uk/collection/P06/current/MCUB/",
    measurementUnit == "m/s" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UVAA/")) %>%
    select(eventID, measurementID, measurementType, measurementTypeID, measurementValue,
           measurementUnit, measurementUnitID)
```

Next, add information on the sampling instrument: 

The bongo had a length of 3m, but I couldn't find any controlled vocabulary for sampling instrument length so I omitted this information from the code. For the sampling instrument

``` {r samplingInstrument, eval = FALSE}
bongo2020_instrument <- bongo2020_meta %>%
  select(eventID = cast,
         Gear) %>%
  mutate(bongo_mesh = 250,
         bongo_opening = 0.5) %>%
  distinct(eventID, .keep_all = TRUE) %>%
  mutate_all(as.character) %>%
  pivot_longer(cols = Gear:bongo_opening,
               names_to = "measurementType",
               values_to = "measurementValue") %>%
  mutate(measurementID = paste(eventID, "bongo", measurementType, sep = ":"),
         measurementTypeID = case_when(
           measurementType == "Gear" ~ "http://vocab.nerc.ac.uk/collection/Q01/current/Q0100002/",
           measurementType == "bongo_mesh" ~ "http://vocab.nerc.ac.uk/collection/Q01/current/Q0100015/",
           measurementType == "bongo_opening" ~ "http://vocab.nerc.ac.uk/collection/Q01/current/Q0100017/"))

bongo2020_instrument <- bongo2020_instrument %>%
  mutate(measurementUnit = case_when(
           measurementType == "bongo_mesh" ~ "um",
           measurementType == "bongo_opening" ~ "m^2"),
         measurementUnitID = case_when(
           measurementUnit == "um" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UMIC/",
           measurementUnit == "m^2" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UMSQ/"),
         measurementValueID = case_when(
           measurementValue == "Bongo" ~ "http://vocab.nerc.ac.uk/collection/L22/current/NETT0176/")) %>%
  select(eventID, measurementID, measurementType, measurementTypeID, measurementValue,
         measurementValueID, measurementUnit, measurementUnitID)
```

Next, we create the eMOF core to associate the length and weight measurements for the individuals collected within the Bongo samples. When the species or genus has been identified, the measurements are associated to the occurrenceID.  

``` {r eMOF, eval = FALSE}
bongo2020_emof <- bongo2020_occ_fnl %>%
  select(eventID = net,
         occurrenceID,
         `Size fraction`,
         length = Length_mm,
         weight = Weight_g,
         `Length type`) %>%
  mutate_all(as.character)
```

Within this dataframe, there are still the data entries that have a length measurements associated to them that's a range (i.e., 15 - 17mm). For these `occurrenceID`s we want to split this column into two, with minimumLength and maximumLength. Afterwards, that dataframe can be merged back in with bongo_emof2. 

``` {r, eval = FALSE}
range <- bongo2020_emof %>%
  # bongo_emof2 needs to be replaced with a table that contains the occurrenceIDs!!
  filter(grepl("-", bongo2020_emof$length)) %>%
  separate(col = length, into = c("minimumLength", "maximumLength"), sep = "\\-") %>%
  mutate(length = " ") # required to join dataframes at later stage. 

# Remove any rows from bongo_emof2 where length_mm contains a range, add two dummy columns (minimumLength and maximumLength) and use rbind() to merge `range` with this newly created dataframe.
temp <- bongo2020_emof[ -grep("-", bongo2020_emof$length), ] %>%
  mutate(minimumLength = " ",
         maximumLength = " ")

bongo2020_emof_fnl <- rbind(range, temp)
```

So now we have a dataframe where:
    * Species have been identified to a species or genus level
    * Length measurement ranges have been split up into columns of minimumLength and maximumLength.

``` {r, eval = FALSE}
bongo2020_emof_fnl <- bongo2020_emof_fnl %>%
  mutate_all(as.character) %>%
  pivot_longer(cols = `Size fraction`:length, ,
               names_to = "measurementType",
               values_to = "measurementValue") %>%
  mutate(measurementType = recode(measurementType,
                                 `Size fraction` = "size_fraction",
                                 `Length type` = "length_type"),
         measurementID = case_when(
      measurementType == "size_fraction" ~ paste(eventID, "size_fraction", sep = ":"),
      measurementType == "length" ~ paste(eventID, "length", sep = ":"),
      measurementType == "length_type" ~ paste(eventID, "length_type", sep = ":"),
      measurementType == "weight" ~ paste(eventID, "weight", sep = ":"),
      measurementType == "maximumLength" ~ paste(eventID, "maxLength", sep = ":"),
      measurementType == "minimumLength" ~ paste(eventID, "minLength", sep = ":")),
    measurementTypeID = case_when(
      measurementType == "size_fraction" ~ "http://vocab.nerc.ac.uk/collection/P01/current/MSHSIZE1/",
      # samplingProtocol
      measurementType == "length" ~ "http://vocab.nerc.ac.uk/collection/P01/current/OBSINDLX/",
      # I want to check if maybe there is a better Controlled Vocab for body size
      measurementType == "maximumLength" ~ "http://vocab.nerc.ac.uk/collection/P01/current/OBSMAXLX/",
      measurementType == "minimumLength" ~ "http://vocab.nerc.ac.uk/collection/P01/current/OBSMINLX/",
      measurementType == "length_type" ~ "http://vocab.nerc.ac.uk/collection/P01/current/OBSINDLX/",
      measurementType == "weight" ~ "http://vocab.nerc.ac.uk/collection/S06/current/S0600253/"), 
    measurementUnit = case_when(
      measurementType == "length" ~ "mm",
      measurementType == "minimumLength" ~ "mm",
      measurementType == "maximumLength" ~ "mm",
      measurementType == "weight" ~ "g",
      measurementType == "size_fraction" ~ "mm"), 
    measurementUnitID = case_when(
      measurementUnit == "mm" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UXMM/",
      measurementUnit == "g" ~ "http://vocab.nerc.ac.uk/collection/P06/current/UGRM/"))
```

